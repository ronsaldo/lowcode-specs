<?xml version="1.0" encoding="utf-8"?><lowcode>    <description>    The Lowcode instruction set defines a register based virtual machine for    C like low-level operations and Smalltalk object oriented pointer    manipulations.                                 <br />    Lowcode has different set of registers, one for integer, another for    object-oriented pointers and another for floating point numbers.                                <br />    Lowcode is encoded using the Sista inline primitives and they starting with    opcode inline primitive.                                <br />    </description>    <!--Sista extended bytecode instructions-->    <sista-instruction firstOpcode="0" lastOpcode="15" mnemonic="pushReceiverVariableSmallIndex" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;fetchPointerofObject(sistaOpcode &amp; 15, receiver));        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self interpreterProxy fetchPointer: instruction opcode sistaOpcode &amp; 15 ofObject: receiver.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;fetchPointerofObject(getOpcode() &amp; 15, getReceiverOopValue());        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="16" lastOpcode="31" mnemonic="pushLiteralVariableSmallIndex" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            UNIMPLEMENTED();        </semantic>        <semantic language="Pharo/VirtualCPU">            self shouldBeImplemented.        </semantic>        <semantic language="C++/LLVM">            abort(); /* Should be implemented */        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="32" lastOpcode="63" mnemonic="pushLiteralSmallIndex" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;fetchPointerofObject(sistaOpcode &amp; 31, literals));        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self literalAt: instruction opcode &amp; 31.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;fetchPointerofObject(getOpcode() &amp; 31, getLiteralsOopValue());        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="64" lastOpcode="71" mnemonic="pushTempSmallIndex" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;fetchPointerofObject(sistaOpcode &amp; 7, temporals));        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self temporalAt: instructions opcode &amp; 7.        </semantic>        <semantic language="C++/LLVM">            object = builder.CreateLoad(getTemporalAt(getOpcode() &amp; 7));        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="72" lastOpcode="75" mnemonic="pushTempSmallIndex2" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;fetchPointerofObject((sistaOpcode &amp; 3) + 8, temporals));        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self temporalAt: instructions opcode &amp; 7 + 8.        </semantic>        <semantic language="C++/LLVM">            object = builder.CreateLoad(getTemporalAt((getOpcode() &amp; 7) + 8));        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="76" lastOpcode="76" mnemonic="pushReceiver" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(receiver);        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self receiver.        </semantic>        <semantic language="C++/LLVM">            object = getReceiverOopValue();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="77" lastOpcode="77" mnemonic="pushTrue" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;trueObject());        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self trueObject.        </semantic>        <semantic language="C++/LLVM">            object = getTrueOopValue();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="78" lastOpcode="78" mnemonic="pushFalse" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;falseObject());        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self falseObject.        </semantic>        <semantic language="C++/LLVM">            object = getFalseOopValue();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="79" lastOpcode="79" mnemonic="pushNil" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;nilObject());        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self nilObject.        </semantic>        <semantic language="C++/LLVM">            object = getNilOopValue();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="80" lastOpcode="80" mnemonic="pushZero" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP_INTEGER(0);        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self zeroObject.        </semantic>        <semantic language="C++/LLVM">            object = getZeroOopValue();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="81" lastOpcode="81" mnemonic="pushOne" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP_INTEGER(1);        </semantic>        <semantic language="Pharo/VirtualCPU">            object := self oneObject.        </semantic>        <semantic language="C++/LLVM">            object = getOneOopValue();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="82" lastOpcode="82" mnemonic="pushThisContext" kind="operation">        <stack-arguments />        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="83" lastOpcode="83" mnemonic="dupTop" kind="operation">        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <oop name="dup1" />            <oop name="dup2" />        </stack-results>        <semantic language="C/Interpreter">            PUSH_OOP(interpreterProxy-&gt;stackValue(0));        </semantic>        <semantic language="Pharo/VirtualCPU">            dup1 := object.            dup2 := object.        </semantic>        <semantic language="C++/LLVM">            dup1 = object;            dup2 = object;        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="88" lastOpcode="88" mnemonic="returnReceiver" kind="terminator">        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            RETURN_OOP(receiver);        </semantic>        <semantic language="Pharo/VirtualCPU">            self returnOop: self receiver.        </semantic>        <semantic language="C++/LLVM">            returnOop(getReceiverOopValue());        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="89" lastOpcode="89" mnemonic="returnTrue" kind="terminator">        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            RETURN_OOP(interpreterProxy-&gt;trueObject());        </semantic>        <semantic language="Pharo/VirtualCPU">            self returnOop: self trueObject.        </semantic>        <semantic language="C++/LLVM">            returnOop(getTrueOopValue());        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="90" lastOpcode="90" mnemonic="returnFalse" kind="terminator">        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            RETURN_OOP(interpreterProxy-&gt;falseObject());        </semantic>        <semantic language="Pharo/VirtualCPU">            self returnOop: self falseObject.        </semantic>        <semantic language="C++/LLVM">            returnOop(getFalseOopValue());        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="91" lastOpcode="91" mnemonic="returnNil" kind="terminator">        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            RETURN_OOP(interpreterProxy-&gt;nilObject());        </semantic>        <semantic language="Pharo/VirtualCPU">            self returnOop: self nilObject.        </semantic>        <semantic language="C++/LLVM">            returnOop(getNilOopValue());        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="92" lastOpcode="92" mnemonic="returnTop" kind="terminator">        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            sqInt top = interpreterProxy-&gt;stackValue(0);            RETURN_OOP(top);        </semantic>        <semantic language="Pharo/VirtualCPU">            self returnOop: object.        </semantic>        <semantic language="C++/LLVM">            returnOop(object);        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="95" lastOpcode="95" mnemonic="nop" kind="operation">        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            /* Do nothing*/        </semantic>        <semantic language="Pharo/VirtualCPU">            &quot; Do nothing &quot;        </semantic>        <semantic language="C++/LLVM">            // Do nothing.        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="119" lastOpcode="119" mnemonic="sendSpecialMessageClass" kind="operation">        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <oop name="objectClass" />        </stack-results>        <semantic language="C/Interpreter">            sqInt object;            sqInt objectClass;            POP_OOP_TO(object);            objectClass = interpreterProxy-&gt;fetchClassOf(object);            CHECK_FAILED();            PUSH_OOP(objectClass);        </semantic>        <semantic language="Pharo/VirtualCPU">            objectClass := self interpreterProxy fetchClassOf: object.            self checkFailed.        </semantic>        <semantic language="C++/LLVM">            objectClass = getLlvmInterpreterProxy()-&gt;fetchClassOf(object);            checkFailed();        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="208" lastOpcode="215" mnemonic="popAndStoreTemp" kind="operation">        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            sqInt value;            POP_OOP_TO(value);            interpreterProxy-&gt;storePointerofObjectwithValue(sistaOpcode &amp; 7, temporals, value);            CHECK_FAILED();        </semantic>        <semantic language="Pharo/VirtualCPU">            (self temporalsAt: instruction opcode &amp; 7) value: object.        </semantic>        <semantic language="C++/LLVM">            builder.CreateStore(object, getTemporalAt(getOpcode() &amp; 7));        </semantic>    </sista-instruction>    <sista-instruction firstOpcode="216" lastOpcode="216" mnemonic="popStackTop" kind="operation">        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            sqInt dummy;            POP_OOP_TO(dummy);        </semantic>        <semantic language="Pharo/VirtualCPU">            &quot; Do Nothing &quot;        </semantic>        <semantic language="C++/LLVM">            // Do Nothing        </semantic>    </sista-instruction>    <!--Lowcode  instructions-->    <instruction opcode="0" mnemonic="add32" kind="operation">        <name>Integer Addition</name>        <description>Integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := first + second.        </semantic>        <semantic language="Smalltalk/Cog">            self AddR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            result = first + second;        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAdd(first, second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>    </instruction>    <instruction opcode="1" mnemonic="add64" kind="operation">        <name>Integer Addition</name>        <description>Integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AddR: secondLow R: firstLow.            self AddcR: secondHigh R: firstHigh.			self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AddR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAdd(first, second);        </semantic>        <semantic language="C/Interpreter">            result = first + second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>    </instruction>    <instruction opcode="2" mnemonic="alloca32" kind="operation">        <name>Alloca</name>        <description>            Allocates variable sized memory in the stack.        </description>        <arguments />        <stack-arguments>            <int32 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            pointer = (uint8_t*)alloca(size);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveAw: coInterpreter nativeStackPointerAddress R: TempReg.            self SubR: size R: TempReg.            self AndCq: -16 R: TempReg.            self MoveR: TempReg R: size.            self MoveR: size Aw: coInterpreter nativeStackPointerAddress.            self ssPushNativeRegister: size.        </semantic>        <semantic language="C++/LLVM">            pointer = builder.CreateAlloca(builder.getInt8Ty(), size);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            nativeStackPointer := self cCoerce:                            ((self cCoerce: nativeStackPointer - size to: 'size_t') bitAnd: -16)                        to: 'char*'.            pointer := nativeStackPointer.        </semantic>    </instruction>    <instruction opcode="3" mnemonic="alloca64" kind="operation">        <name>Alloca</name>        <description>            Allocates variable sized memory in the stack.        </description>        <arguments />        <stack-arguments>            <int64 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            pointer = alloca(size);        </semantic>        <semantic language="Smalltalk/Cog/32">            self SubR: sizeLow R: SPReg.            self MoveR: SPReg R: sizeLow.            self ssPushNativeRegister: sizeLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SubR: size R: SPReg.            self MoveR: SPReg R: size.            self ssPushNativeRegister: size.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            nativeStackPointer := nativeStackPointer - size.            pointer := nativeStackPointer.        </semantic>        <semantic language="C++/LLVM">            pointer = builder.CreateAlloca(builder.getInt8Ty(), size);        </semantic>    </instruction>    <instruction opcode="4" mnemonic="and32" kind="operation">        <name>Bitwise And</name>        <description>Performs a bitwise and operation.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first &amp; second;        </semantic>        <semantic language="Smalltalk/Cog">            self AndR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitAnd: second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAnd(first, second);        </semantic>    </instruction>    <instruction opcode="5" mnemonic="and64" kind="operation">        <name>Bitwise And</name>        <description>Performs a bitwise and operation.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AndR: secondLow R: firstLow.            self AndR: secondHigh R: firstHigh.            self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndR: second R: first.            self ssPushNativeRegister: first.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAnd(first, second);        </semantic>        <semantic language="C/Interpreter">            result = first &amp; second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitAnd: second.        </semantic>    </instruction>    <instruction opcode="6" mnemonic="arithmeticRightShift32" kind="operation">        <name>Arithmetic Right Shift</name>        <description>Performs an arithmetic right shifting.</description>        <arguments />        <stack-arguments>            <int32 name="value" />            <int32 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = value &gt;&gt; shiftAmount;        </semantic>        <semantic language="Smalltalk/Cog">            self ArithmeticShiftRightR: shiftAmount R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAShr(value, shiftAmount);        </semantic>    </instruction>    <instruction opcode="7" mnemonic="arithmeticRightShift64" kind="operation">        <name>Arithmetic Right Shift</name>        <description>Performs an arithmetic right shifting.</description>        <arguments />        <stack-arguments>            <int64 name="value" />            <int64 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = value &gt;&gt; shiftAmount;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAShr(value, shiftAmount);        </semantic>    </instruction>    <instruction opcode="8" mnemonic="beginCall" kind="operation">        <name>Begins a function call.</name>        <description>Begins a function call</description>        <arguments>            <extend-a name="alignment" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            BEGIN_CALL(alignment);        </semantic>        <semantic language="Smalltalk/Cog">            self beginHighLevelCall: alignment.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            hostPlatformStoredSP := hostPlatformSP.            hostPlatformSP := self cCoerce:                            ((self cCoerce: hostPlatformSP to: 'size_t') bitAnd: alignment negated)                        to: 'char*'.        </semantic>        <semantic language="C++/LLVM">            beginCall(alignment);        </semantic>    </instruction>    <instruction opcode="9" mnemonic="branchFalse32" kind="branch">        <name>Branch On False</name>        <description>It performs an jump if the Int32 present in the stack is equals to zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int32 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU">            (cond = vcpu word0) ifTrue: [                instruction branchBlock compiledBlock compileBlock: stack copy            ] ifFalse: [                instruction nextBlock compiledBlock compileBlock: stack copy            ].        </semantic>        <semantic language="Smalltalk/Cog">            self genJumpIfBoolean32: false cond: cond to: dest.        </semantic>        <semantic language="C/Interpreter">            if(!cond)                pc = dest;        </semantic>        <semantic language="C++/LLVM">            llvm::Value *boolCond = builder.CreateICmpEQ(cond, builder.getInt32(0));            builder.CreateCondBr(boolCond, getBranchBlock()-&gt;getLlvmBasicBlock(),                                    getNextBlock()-&gt;getLlvmBasicBlock());        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond = 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="10" mnemonic="branchFalse64" kind="branch">        <name>Branch On False</name>        <description>It performs an jump if the Int64 present in the stack is equals to zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int64 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self OrR: condHigh R: condLow.            self genJumpIfBoolean64: true cond: condLow to: dest.        </semantic>        <semantic language="Smalltalk/Cog/64">            self genJumpIfBoolean64: true cond: cond to: dest.        </semantic>        <semantic language="Pharo/VirtualCPU">            (cond = vcpu word0) ifTrue: [                instruction branchBlock compiledBlock compileBlock: stack copy            ] ifFalse: [                instruction nextBlock compiledBlock compileBlock: stack copy            ].        </semantic>        <semantic language="C++/LLVM">            llvm::Value *boolCond = builder.CreateICmpEQ(cond, builder.getInt64(0));            builder.CreateCondBr(boolCond, getBranchBlock()-&gt;getLlvmBasicBlock(),                                    getNextBlock()-&gt;getLlvmBasicBlock());        </semantic>        <semantic language="C/Interpreter">            if(!cond)                pc = dest;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond = 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="11" mnemonic="branchTrue32" kind="branch">        <name>Branch On True</name>        <description>It performs an jump if the Int32 present in the stack is different than zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int32 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU">            (cond = vcpu word0) ifFalse: [                instruction branchBlock compiledBlock compileBlock: stack copy            ] ifTrue: [                instruction nextBlock compiledBlock compileBlock: stack copy            ].        </semantic>        <semantic language="Smalltalk/Cog">            self genJumpIfBoolean32: true cond: cond to: dest.        </semantic>        <semantic language="C/Interpreter">            if(cond)                pc = dest;        </semantic>        <semantic language="C++/LLVM">            llvm::Value *boolCond = builder.CreateICmpNE(cond, builder.getInt32(0));            builder.CreateCondBr(boolCond, getBranchBlock()-&gt;getLlvmBasicBlock(),                                    getNextBlock()-&gt;getLlvmBasicBlock());        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond ~= 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="12" mnemonic="branchTrue64" kind="branch">        <name>Branch On True</name>        <description>It performs an jump if the Int64 present in the stack is different than zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int64 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self OrR: condHigh R: condLow.            self genJumpIfBoolean64: true cond: condLow to: dest.        </semantic>        <semantic language="Smalltalk/Cog/64">            self genJumpIfBoolean64: true cond: cond to: dest.        </semantic>        <semantic language="Pharo/VirtualCPU">            (cond = vcpu word0) ifFalse: [                instruction branchBlock compiledBlock compileBlock: stack copy            ] ifTrue: [                instruction nextBlock compiledBlock compileBlock: stack copy            ].        </semantic>        <semantic language="C++/LLVM">            llvm::Value *boolCond = builder.CreateICmpNE(cond, builder.getInt64(0));            builder.CreateCondBr(boolCond, getBranchBlock()-&gt;getLlvmBasicBlock(),                                    getNextBlock()-&gt;getLlvmBasicBlock());        </semantic>        <semantic language="C/Interpreter">            if(cond)                pc = dest;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond ~= 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="13" mnemonic="callArgumentFloat32" kind="operation">        <name>Push Float32 call argument</name>        <description>Pushes a 32-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <float32 name="argumentValue" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            CALL_ARGUMENT_FLOAT32(argumentValue);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: DPFPReg0.	        self ssNativePop: 1.            self MoveRs: DPFPReg0 M32: BytesPerWord negated r: SPReg.            self SubCq: BytesPerWord R: SPReg.            currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentFloat32: argumentValue.        </semantic>        <semantic language="C++/LLVM">            callArgumentFloat32(argumentValue);        </semantic>    </instruction>    <instruction opcode="14" mnemonic="callArgumentFloat64" kind="operation">        <name>Push Float64 call argument</name>        <description>Pushes a 64-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <float64 name="argumentValue" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            CALL_ARGUMENT_FLOAT64(argumentValue);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: DPFPReg0.	        self ssNativePop: 1.            self MoveRd: DPFPReg0 M64: -8 r: SPReg.            self SubCq: 8 R: SPReg.            currentCallCleanUpSize := currentCallCleanUpSize + 8.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentFloat64: argumentValue.        </semantic>        <semantic language="C++/LLVM">            callArgumentFloat64(argumentValue);        </semantic>    </instruction>    <instruction opcode="15" mnemonic="callArgumentInt32" kind="operation">        <name>Pushes Int32 call argument</name>        <description>Pushes a 32-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            CALL_ARGUMENT_INT32(value);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentInt32: value.        </semantic>        <semantic language="C++/LLVM">            callArgumentInt32(value);        </semantic>    </instruction>    <instruction opcode="16" mnemonic="callArgumentInt64" kind="operation">        <name>Push Int64 call argument</name>        <description>Pushes a 64-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/Raw">            BytesPerWord = 4 ifTrue: [	            self ssNativeTop nativeStackPopToReg: TempReg secondReg: ReceiverResultReg.	            self ssNativePop: 1.                self PushR: TempReg.                self PushR: ReceiverResultReg.                currentCallCleanUpSize := currentCallCleanUpSize + 8.            ] ifFalse: [	            self ssNativeTop nativeStackPopToReg: TempReg.	            self ssNativePop: 1.                self PushR: TempReg.                currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.            ].        </semantic>        <semantic language="C++/LLVM">            callArgumentInt64(value);        </semantic>        <semantic language="C/Interpreter">            CALL_ARGUMENT_INT64(value);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentInt64: value.        </semantic>    </instruction>    <instruction opcode="17" mnemonic="callArgumentPointer" kind="operation">        <name>Push Pointer call argument</name>        <description>Pushes a pointer to the call stack.</description>        <arguments />        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            CALL_ARGUMENT_POINTER(pointerValue);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentPointer: pointerValue.        </semantic>        <semantic language="C++/LLVM">            callArgumentPointer(pointerValue);        </semantic>    </instruction>    <instruction opcode="18" mnemonic="callArgumentStructure" kind="operation">        <name>Push structure call argument</name>        <description>Pushes a pointer to the call stack.</description>        <arguments>            <extend-a name="structureSize" />        </arguments>        <stack-arguments>            <pointer name="structurePointer" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            CALL_ARGUMENT_STRUCTURE(structurePointer, structureSize);        </semantic>        <semantic language="Smalltalk/Cog/Raw">            "Fetch the pointer"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            "Allocate space"            self SubCq: currentCallCleanUpSize R: SPReg .            "Copy the structure"            backEnd genMemCopy: TempReg to: SPReg constantSize: extA.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentStructure: structurePointer Sized: structureSize.        </semantic>        <semantic language="C++/LLVM">            callArgumentStructure(structureSize, structurePointer);        </semantic>    </instruction>    <instruction opcode="19" mnemonic="callInstruction" kind="operation">        <name>Low-Level call</name>        <description>This instruction performs a Low-Level call.</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>        <semantic language="Smalltalk/Cog">            self CallRT: function.        </semantic>    </instruction>    <instruction opcode="20" mnemonic="callPhysical" kind="operation">        <name>Push Int32 from physical register</name>        <description>Pushes an Int32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>        <semantic language="Smalltalk/Cog">            self CallR: registerID.        </semantic>    </instruction>    <instruction opcode="21" mnemonic="checkSessionIdentifier" kind="operation">        <name>Pushes true or false if the session ID matches</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments>            <extend-a name="expectedSession" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            value := expectedSession = (self sessionIdentifier).        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: (expectedSession = coInterpreter getThisSessionID ifTrue: [1] ifFalse: [0]).        </semantic>        <semantic language="C/Interpreter">            if(!Lowcode_sessionInitialized)                Lowcode_initializeSession();            value = expectedSession == Lowcode_sessionIdentifier;        </semantic>        <semantic language="C++/LLVM">            value = builder.getInt32(expectedSession == LowcodeLLVMContext::get().getSessionIdentifier());        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (expectedSession = self getThisSessionID) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="22" mnemonic="compareAndSwap32" kind="operation">        <name>Compare and Swap 32 Bits</name>        <description>            Compares a 32 bit value in memory with a reference value,            if they are equal it swaps the memory location with a new value.            It returns the old value in the memory location.            This operation is guaranteed to be atomic.        </description>        <arguments />        <stack-arguments>            <pointer name="check" />            <int32 name="oldValue" />            <int32 name="newValue" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            UNIMPLEMENTED();        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateAtomicCmpXchg(check, oldValue, newValue, llvm::Monotonic);        </semantic>    </instruction>    <instruction opcode="23" mnemonic="div32" kind="operation">        <name>Integer Signed Division</name>        <description>Integer signed division without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := first / second.        </semantic>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: first Rem: second.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            result = first / second;        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSDiv(first, second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first // second.        </semantic>    </instruction>    <instruction opcode="24" mnemonic="div64" kind="operation">        <name>Integer Signed Division</name>        <description>Integer signed division without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = first / second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first // second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSDiv(first, second);        </semantic>    </instruction>    <instruction opcode="25" mnemonic="duplicateFloat32" kind="operation">        <name>Duplicate Float32</name>        <description>It duplicates the Float32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <float32 name="dup1" aliased="true" />            <float32 name="dup2" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            dup1 := value.            dup2 := value.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveRs: value Rs: dup2.            self ssPushRegisterSingleFloat: value;                ssPushRegisterSingleFloat: dup2.        </semantic>        <semantic language="C/Interpreter">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="C++/LLVM">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="26" mnemonic="duplicateFloat64" kind="operation">        <name>Duplicate Float64</name>        <description>It duplicates the Float64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="dup1" aliased="true" />            <float64 name="dup2" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            dup1 := value.            dup2 := value.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveRd: value Rd: dup2.            self ssPushRegisterDoubleFloat: value;                ssPushRegisterDoubleFloat: dup2.        </semantic>        <semantic language="C/Interpreter">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="C++/LLVM">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="27" mnemonic="duplicateInt32" kind="operation">        <name>Duplicate Int32</name>        <description>It duplicates the Int32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="dup1" aliased="true" />            <int32 name="dup2" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            dup1 := value.            dup2 := value.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: value R: dup2.            self ssPushNativeRegister: value;                ssPushNativeRegister: dup2.        </semantic>        <semantic language="C/Interpreter">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="C++/LLVM">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="28" mnemonic="duplicateInt64" kind="operation">        <name>Duplicate Int64</name>        <description>It duplicates the Int64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="dup1" aliased="true" />            <int64 name="dup2" />        </stack-results>        <semantic language="Smalltalk/Cog/64">            self MoveR: value R: dup2.            self ssPushNativeRegister: value.            self ssPushNativeRegister: dup2.        </semantic>        <semantic language="Smalltalk/Cog/32">            self MoveR: valueLow R: dup2Low.            self MoveR: valueHigh R: dup2High.            self ssPushRegister: valueLow secondRegister: valueHigh.            self ssPushRegister: dup2Low secondRegister: dup2High.        </semantic>        <semantic language="Pharo/VirtualCPU">            dup1 := value.            dup2 := value.        </semantic>        <semantic language="C++/LLVM">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="C/Interpreter">            dup1 = value;            dup2 = value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="29" mnemonic="duplicatePointer" kind="operation">        <name>Duplicate Pointer</name>        <description>It duplicates the pointer present in the top of the stack</description>        <arguments />        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results>            <pointer name="dup1" aliased="true" />            <pointer name="dup2" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            dup1 := pointerValue.            dup2 := pointerValue.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: pointerValue R: dup2.            self ssPushNativeRegister: pointerValue;                ssPushNativeRegister: dup2.        </semantic>        <semantic language="C/Interpreter">            dup1 = pointerValue;            dup2 = pointerValue;        </semantic>        <semantic language="C++/LLVM">            dup1 = pointerValue;            dup2 = pointerValue;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := pointerValue.            dup2 := pointerValue.        </semantic>    </instruction>    <instruction opcode="30" mnemonic="effectiveAddress32" kind="operation">        <name>Compute Effective Address 32-bit</name>        <description>It computes an effective address 32-bit factors.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int32 name="index" />            <int32 name="scale" />            <int32 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := base + (index*scale) + offset.        </semantic>        <semantic language="Smalltalk/Cog">            self MulR: scale R: index.            self AddR: index R: base.            self AddR: offset R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="C/Interpreter">            result = ((char*)base) + index*scale + offset;        </semantic>        <semantic language="C++/LLVM">            llvm::Value *newOffset = builder.CreateAdd(offset, builder.CreateMul(scale, index));            result = builder.CreateGEP(base, newOffset);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := base + (index*scale) + offset.        </semantic>    </instruction>    <instruction opcode="31" mnemonic="effectiveAddress64" kind="operation">        <name>Compute Effective Address 64-bit</name>        <description>It computes an effective address using 64-bit factors.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int64 name="index" />            <int64 name="scale" />            <int64 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = ((char*)base) + index*scale + offset;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := base + (index*scale) + offset.        </semantic>        <semantic language="Pharo/VirtualCPU">            result := base + (index*scale) + offset.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *newOffset = builder.CreateAdd(offset, builder.CreateMul(scale, index));            result = builder.CreateGEP(base, newOffset);        </semantic>    </instruction>    <instruction opcode="32" mnemonic="endCall" kind="operation">        <name>End a function call.</name>        <description>It ends a function call by cleaning the stack.</description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            END_CALL();        </semantic>        <semantic language="Smalltalk/Cog">            self endHighLevelCallWithCleanup.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            hostPlatformSP := hostPlatformStoredSP.        </semantic>        <semantic language="C++/LLVM">            endCall();        </semantic>    </instruction>    <instruction opcode="33" mnemonic="endCallNoCleanup" kind="operation">        <name>End a function call.</name>        <description>It ends a function call without cleaning the stack.</description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            END_CALL_NO_CLEANUP();        </semantic>        <semantic language="Smalltalk/Cog">            self endHighLevelCallWithoutCleanup.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            &quot;Nop&quot;            hostPlatformSP := hostPlatformSP.        </semantic>        <semantic language="C++/LLVM">            endCallNoCleanup();        </semantic>    </instruction>    <instruction opcode="34" mnemonic="fail" kind="terminator">        <name>Returns with an error.</name>        <description>Return with error </description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            return interpreterProxy-&gt;primitiveFail();        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            self ensureReceiverResultRegContainsSelf.            self MoveCq: 0 R: TempReg.            self CallRT: ceSendInlinePrimitiveFailed.            self annotateBytecode: self Label.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self internalPush: self receiver.            self internalPush: (objectMemory integerObjectOf: 0).            messageSelector := self splObj: SelectorInlinePrimitiveFailed.			argumentCount := 1.            self normalSend.        </semantic>        <semantic language="C++/LLVM">            builder.CreateRet(getLlvmInterpreterProxy()-&gt;primitiveFail());        </semantic>    </instruction>    <instruction opcode="35" mnemonic="failWithCode" kind="terminator">        <name>Returns with an error.</name>        <description>Return with error </description>        <arguments>            <extend-a name="errorCode" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            return interpreterProxy-&gt;primitiveFailFor(errorCode);        </semantic>        <semantic language="Smalltalk/Cog">            self ensureReceiverResultRegContainsSelf.            self MoveCq: errorCode R: TempReg.            self CallRT: ceSendInlinePrimitiveFailed.            self annotateBytecode: self Label.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self internalPush: self receiver.            self internalPush: (objectMemory integerObjectOf: errorCode).            messageSelector := self splObj: SelectorInlinePrimitiveFailed.			argumentCount := 1.            self normalSend.        </semantic>        <semantic language="C++/LLVM">            builder.CreateRet(getLlvmInterpreterProxy()-&gt;primitiveFailFor(errorCode));        </semantic>    </instruction>    <instruction opcode="36" mnemonic="float32Add" kind="operation">        <name>Float32 addition</name>        <description>It Performs the addition of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first + second;        </semantic>        <semantic language="Smalltalk/Cog">            self AddRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFAdd(first, second);        </semantic>    </instruction>    <instruction opcode="37" mnemonic="float32Div" kind="operation">        <name>Float32 division</name>        <description>It performs the division of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first / second;        </semantic>        <semantic language="Smalltalk/Cog">            self DivRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first / second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFDiv(first, second);        </semantic>    </instruction>    <instruction opcode="38" mnemonic="float32Equal" kind="operation">        <name>Float32 Equality</name>        <description>Float32 equality.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first == second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPNotEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOEQ(first, second));        </semantic>    </instruction>    <instruction opcode="39" mnemonic="float32Great" kind="operation">        <name>Float32 Great Than</name>        <description>Float32 great than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt; second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPLessOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOGT(first, second));        </semantic>    </instruction>    <instruction opcode="40" mnemonic="float32GreatEqual" kind="operation">        <name>Float32 Great or Equal Than</name>        <description>Float32 great or equal than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt;= second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPLess: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOGE(first, second));        </semantic>    </instruction>    <instruction opcode="41" mnemonic="float32Less" kind="operation">        <name>Float32 Less Than</name>        <description>Float32 less than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt; second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPGreaterOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOLT(first, second));        </semantic>    </instruction>    <instruction opcode="42" mnemonic="float32LessEqual" kind="operation">        <name>Float32 Less or Eual Than</name>        <description>Float32 less or equal than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt;= second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPGreater: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOLE(first, second));        </semantic>    </instruction>    <instruction opcode="43" mnemonic="float32Mul" kind="operation">        <name>Float32 multiplication</name>        <description>It performs the multiplication of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first * second;        </semantic>        <semantic language="Smalltalk/Cog">            self MulRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFMul(first, second);        </semantic>    </instruction>    <instruction opcode="44" mnemonic="float32NotEqual" kind="operation">        <name>Float32 Inequality</name>        <description>Float32 not equal.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first != second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpONE(first, second));        </semantic>    </instruction>    <instruction opcode="45" mnemonic="float32Sub" kind="operation">        <name>Float32 subtraction</name>        <description>It performs the subtraction of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first - second;        </semantic>        <semantic language="Smalltalk/Cog">            self SubRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFSub(first, second);        </semantic>    </instruction>    <instruction opcode="46" mnemonic="float32ToFloat64" kind="operation">        <name>Float32 to Float64</name>        <description>It converts a single precision floating point number into                    a double precision floating point number        </description>        <arguments />        <stack-arguments>            <float32 name="singleFloatValue" />        </stack-arguments>        <stack-results>            <float64 name="doubleResult" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            doubleResult = singleFloatValue;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertRs: singleFloatValue Rd: singleFloatValue.            self ssPushRegisterDoubleFloat: singleFloatValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            doubleResult := self cCoerce: singleFloatValue to: 'double'.        </semantic>        <semantic language="C++/LLVM">            doubleResult = builder.CreateFPCast(singleFloatValue, builder.getDoubleTy());        </semantic>    </instruction>    <instruction opcode="47" mnemonic="float32ToInt32" kind="operation">        <name>Float32 to Int32</name>        <description>It converts single precision floating point number into 32-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (int32_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertRs: value R: result.            self ssPushNativeRegister: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'sqInt'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFPToSI(value, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="48" mnemonic="float32ToInt64" kind="operation">        <name>Float32 to Int64</name>        <description>It converts a single precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (int64_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'sqLong'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFPToSI(value, builder.getInt64Ty());        </semantic>    </instruction>    <instruction opcode="49" mnemonic="float32ToUInt32" kind="operation">        <name>Float32 to UInt32</name>        <description>It converts single precision floating point number into 32-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint32_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertRs: value R: result.            self ssPushNativeRegister: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint32_t'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFPToUI(value, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="50" mnemonic="float32ToUInt64" kind="operation">        <name>Float32 to UInt64</name>        <description>It converts a single precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint64_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint64_t'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFPToUI(value, builder.getInt64Ty());        </semantic>    </instruction>    <instruction opcode="51" mnemonic="float64Add" kind="operation">        <name>Float64 addition</name>        <description>It performs the addition of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first + second;        </semantic>        <semantic language="Smalltalk/Cog">            self AddRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFAdd(first, second);        </semantic>    </instruction>    <instruction opcode="52" mnemonic="float64Div" kind="operation">        <name>Float64 division</name>        <description>It performs the division of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first / second;        </semantic>        <semantic language="Smalltalk/Cog">            self DivRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first / second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFDiv(first, second);        </semantic>    </instruction>    <instruction opcode="53" mnemonic="float64Equal" kind="operation">        <name>Float64 Equality</name>        <description>Float64 equality.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first == second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPNotEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOEQ(first, second));        </semantic>    </instruction>    <instruction opcode="54" mnemonic="float64Great" kind="operation">        <name>Float64 Great Than</name>        <description>Float64 great than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt; second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPLessOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOGT(first, second));        </semantic>    </instruction>    <instruction opcode="55" mnemonic="float64GreatEqual" kind="operation">        <name>Float64 Great or Equal Than</name>        <description>Float64 great or equal than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt;= second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPLess: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOGE(first, second));        </semantic>    </instruction>    <instruction opcode="56" mnemonic="float64Less" kind="operation">        <name>Float64 Less Than</name>        <description>Float64 less than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt; second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPGreaterOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOLT(first, second));        </semantic>    </instruction>    <instruction opcode="57" mnemonic="float64LessEqual" kind="operation">        <name>Float64 Less or Equal Than</name>        <description>Float32 less or equal than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt;= second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPGreater: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpOLE(first, second));        </semantic>    </instruction>    <instruction opcode="58" mnemonic="float64Mul" kind="operation">        <name>Float64 multiplication</name>        <description>It performs the multiplication of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first * second;        </semantic>        <semantic language="Smalltalk/Cog">            self MulRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFMul(first, second);        </semantic>    </instruction>    <instruction opcode="59" mnemonic="float64NotEqual" kind="operation">        <name>Float64 Inequality</name>        <description>Float64 not equal.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first != second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateFCmpONE(first, second));        </semantic>    </instruction>    <instruction opcode="60" mnemonic="float64Sub" kind="operation">        <name>Float64 subtraction</name>        <description>It performs the subtraction of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first - second;        </semantic>        <semantic language="Smalltalk/Cog">            self SubRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateFSub(first, second);        </semantic>    </instruction>    <instruction opcode="61" mnemonic="float64ToFloat32" kind="operation">        <name>Float64 to Float32</name>        <description>It converts a double precision floating point number into                    a single precision floating point number        </description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <float32 name="singleFloatResult" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            singleFloatResult = (float)floatValue;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertRd: floatValue Rs: floatValue.            self ssPushRegisterSingleFloat: floatValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            singleFloatResult := self cCoerce: floatValue to: 'float'.        </semantic>        <semantic language="C++/LLVM">            singleFloatResult = builder.CreateFPCast(floatValue, builder.getFloatTy());        </semantic>    </instruction>    <instruction opcode="62" mnemonic="float64ToInt32" kind="operation">        <name>Float64 to Int32</name>        <description>It converts double precision floating point number into a 32-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int32 name="int32Result" />        </stack-results>        <semantic language="C/Interpreter">            int32Result = (int32_t)floatValue;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertRd: floatValue R: int32Result.            self ssPushNativeRegister: int32Result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            int32Result := self cCoerce: floatValue to: 'sqInt'.        </semantic>        <semantic language="C++/LLVM">            int32Result = builder.CreateFPToSI(floatValue, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="63" mnemonic="float64ToInt64" kind="operation">        <name>Float64 to Int64</name>        <description>It converts a double precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int64 name="int64Result" />        </stack-results>        <semantic language="C/Interpreter">            int64Result = (int64_t)floatValue;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            int64Result := self cCoerce: floatValue to: 'sqLong'.        </semantic>        <semantic language="C++/LLVM">            int64Result = builder.CreateFPToSI(floatValue, builder.getInt64Ty());        </semantic>    </instruction>    <instruction opcode="64" mnemonic="float64ToUInt32" kind="operation">        <name>Float64 to UInt32</name>        <description>It converts double precision floating point number into a 32-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int32 name="int64Result" />        </stack-results>        <semantic language="C/Interpreter">            int64Result = (uint32_t)floatValue;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertRd: floatValue R: int64Result.            self ssPushNativeRegister: int64Result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            int64Result := self cCoerce: floatValue to: 'uint32_t'.        </semantic>        <semantic language="C++/LLVM">            int64Result = builder.CreateFPToUI(floatValue, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="65" mnemonic="float64ToUInt64" kind="operation">        <name>Float64 to UInt64</name>        <description>It converts a double precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int64 name="int64Result" />        </stack-results>        <semantic language="C/Interpreter">            int64Result = (uint64_t)floatValue;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            int64Result := self cCoerce: floatValue to: 'uint64_t'.        </semantic>        <semantic language="C++/LLVM">            int64Result = builder.CreateFPToUI(floatValue, builder.getInt64Ty());        </semantic>    </instruction>    <instruction opcode="66" mnemonic="free" kind="operation">        <name>Frees Memory</name>        <description>            Frees previously allocated memory in the heap.        </description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            free(pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            pointer ~= ReceiverResultReg ifTrue: [self MoveR: pointer R: ReceiverResultReg ].            self CallRT: ceFreeTrampoline.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self free: pointer.        </semantic>        <semantic language="C++/LLVM">            builder.CreateCall(getFreeFunction(), pointer);        </semantic>    </instruction>    <instruction opcode="67" mnemonic="int32Equal" kind="operation">        <name>Int32 Equality</name>        <description>Int32 equality.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            value := vcpu word0.            (first = second) ifTrue: [value value: 1].        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            value = first == second;         </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpEQ(first, second));        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="68" mnemonic="int32Great" kind="operation">        <name>Int32 Great Than</name>        <description>Int32 great than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt; second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpLessOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSGT(first, second));        </semantic>    </instruction>    <instruction opcode="69" mnemonic="int32GreatEqual" kind="operation">        <name>Int32 Great or EqualThan</name>        <description>Int32 great or equal than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt;= second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpLess: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSGE(first, second));        </semantic>    </instruction>    <instruction opcode="70" mnemonic="int32Less" kind="operation">        <name>Int32 Less Than</name>        <description>Int32 not equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt; second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpGreaterOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSLT(first, second));        </semantic>    </instruction>    <instruction opcode="71" mnemonic="int32LessEqual" kind="operation">        <name>Int32 Less or Equal Than</name>        <description>Int32 less equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt;= second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpGreater: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSLE(first, second));        </semantic>    </instruction>    <instruction opcode="72" mnemonic="int32NotEqual" kind="operation">        <name>Int32 Inequality</name>        <description>Float32 not equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            value := vcpu word0.            (first = second) ifFalse: [value value: 1].        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            value = first != second;         </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpNE(first, second));        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="73" mnemonic="int32ToFloat32" kind="operation">        <name>Int32 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (int32_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rs: result.            self ssPushRegisterSingleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'float'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSIToFP(value, builder.getFloatTy());        </semantic>    </instruction>    <instruction opcode="74" mnemonic="int32ToFloat64" kind="operation">        <name>Int32 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (int32_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rd: result.            self ssPushRegisterDoubleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'double'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSIToFP(value, builder.getDoubleTy());        </semantic>    </instruction>    <instruction opcode="75" mnemonic="int32ToPointer" kind="operation">        <name>Int32 to Pointer</name>        <description>It converts a 32-bit integer into a pointer.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (void*)(uintptr_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            &quot;TODO: Perform a NOP here&quot;            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uintptr_t'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateIntToPtr(value, builder.getInt8PtrTy());        </semantic>    </instruction>    <instruction opcode="76" mnemonic="int64Equal" kind="operation">        <name>Int64 Equality</name>        <description>Int64 equality.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump falseJump2 falseLabel contJump" language="Smalltalk/Cog/32">            self CmpR: secondHigh R: firstHigh.            falseJump := self JumpNonZero: 0.            self CmpR: secondLow R: firstLow.            falseJump2 := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: firstLow.            contJump := self Jump: 0.            &quot;False result&quot;            falseLabel := self MoveCq: 0 R: firstLow.            falseJump jmpTarget: falseLabel.            falseJump2 jmpTarget: falseLabel.            contJump jmpTarget: self Label.            self ssPushNativeRegister: firstLow.        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog/64">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpEQ(first, second));        </semantic>        <semantic language="C/Interpreter">            value = first == second;         </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="77" mnemonic="int64Great" kind="operation">        <name>Int64 Great Than</name>        <description>Int64 great than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt; second;         </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSGT(first, second));        </semantic>    </instruction>    <instruction opcode="78" mnemonic="int64GreatEqual" kind="operation">        <name>Int64 Great or EqualThan</name>        <description>Int64 great or equal than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &gt;= second;         </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSGE(first, second));        </semantic>    </instruction>    <instruction opcode="79" mnemonic="int64Less" kind="operation">        <name>Int64 Less Than</name>        <description>Int64 not equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt; second;         </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSLT(first, second));        </semantic>    </instruction>    <instruction opcode="80" mnemonic="int64LessEqual" kind="operation">        <name>Int64 Less or Equal Than</name>        <description>Int64 less equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first &lt;= second;         </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpSLE(first, second));        </semantic>    </instruction>    <instruction opcode="81" mnemonic="int64NotEqual" kind="operation">        <name>Int64 Inequality</name>        <description>Float64 not equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump falseJump2 falseLabel contJump" language="Smalltalk/Cog/32">            self CmpR: secondHigh R: firstHigh.            falseJump := self JumpNonZero: 0.            self CmpR: secondLow R: firstLow.            falseJump2 := self JumpNonZero: 0.            &quot;False result&quot;            self MoveCq: 0 R: firstLow.            contJump := self Jump: 0.            &quot;True result&quot;            falseLabel := self MoveCq: 1 R: firstLow.            falseJump jmpTarget: falseLabel.            falseJump2 jmpTarget: falseLabel.            contJump jmpTarget: self Label.            self ssPushNativeRegister: firstLow.        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog/64">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpNE(first, second));        </semantic>        <semantic language="C/Interpreter">            value = first != second;         </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="82" mnemonic="int64ToFloat32" kind="operation">        <name>Int64 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (int64_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'float'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSIToFP(value, builder.getFloatTy());        </semantic>    </instruction>    <instruction opcode="83" mnemonic="int64ToFloat64" kind="operation">        <name>Int64 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (int64_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'double'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSIToFP(value, builder.getDoubleTy());        </semantic>    </instruction>    <instruction opcode="84" mnemonic="int64ToPointer" kind="operation">        <name>Int64 to Pointer</name>        <description>It converts a 64-bit integer into a pointer.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreatePtrToInt(value, builder.getInt8PtrTy());        </semantic>        <semantic language="C/Interpreter">            result = (void*)(uintptr_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce:                        (self cCoerce: value to: 'intptr_t')                       to: 'char*'.        </semantic>    </instruction>    <instruction opcode="85" mnemonic="jump" kind="jump">        <name>Jump</name>        <description>Performs an Unconditional Jump</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Pharo/VirtualCPU">            instruction jumpBlock compiledBlock compileBlock: stack copy.        </semantic>        <semantic language="Smalltalk/Cog">            extB &lt; 0 ifTrue:                [extB := 0.                 ^self genJumpBackTo: dest].            self genJumpTo: dest.            &quot;The bytecode must be mapped since it can be either forward or backward, and             backwards branches must be mapped. So if forward, we need to map.&quot;            self annotateBytecode: self lastOpcode.        </semantic>        <semantic language="C/Interpreter">            pc = dest;        </semantic>        <semantic language="C++/LLVM">            builder.CreateBr(getJumpBlock()-&gt;getLlvmBasicBlock());        </semantic>        <semantic language="Smalltalk/StackInterpreter">            localIP := dest.           	self cppIf: MULTIPLEBYTECODESETS           		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]           		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP].        </semantic>    </instruction>    <instruction opcode="86" mnemonic="leftShift32" kind="operation">        <name>Left Shift</name>        <description>Performs a left shifting.</description>        <arguments />        <stack-arguments>            <int32 name="value" />            <int32 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = value &lt;&lt; shiftAmount;        </semantic>        <semantic language="Smalltalk/Cog">            self LogicalShiftLeftR: shiftAmount R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &lt;&lt; shiftAmount.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateShl(value, shiftAmount);        </semantic>    </instruction>    <instruction opcode="87" mnemonic="leftShift64" kind="operation">        <name>Left Shift</name>        <description>Performs a left shifting.</description>        <arguments />        <stack-arguments>            <int64 name="value" />            <int64 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = value &lt;&lt; shiftAmount;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &lt;&lt; shiftAmount.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateShl(value, shiftAmount);        </semantic>    </instruction>    <instruction opcode="88" mnemonic="loadFloat32FromMemory" kind="operation">        <name>Load Float 32 from Memory</name>        <description>Loads a float 32 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <float32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = *((float*)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM32: 0 r: pointer Rs: value.			self ssPushRegisterSingleFloat: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self singleFloatAtPointer: pointer.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getFloatPtrTy(builder.getContext()));            value = builder.CreateLoad(castedPointer);        </semantic>    </instruction>    <instruction opcode="89" mnemonic="loadFloat64FromMemory" kind="operation">        <name>Load Float 64 from Memory</name>        <description>Loads a float 64 from.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <float64 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = *((double*)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM64: 0 r: pointer Rd: value.			self ssPushRegisterDoubleFloat: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self floatAtPointer: pointer.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getDoublePtrTy(builder.getContext()));            value = builder.CreateLoad(castedPointer);        </semantic>    </instruction>    <instruction opcode="90" mnemonic="loadInt16FromMemory" kind="operation">        <name>Load U16 from Memory</name>        <description>Loads an U16 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = *((int16_t*)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM16: 0 r: pointer R: value.            self SignExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int16AtPointer: pointer.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt16PtrTy(builder.getContext()));            value = builder.CreateSExt(builder.CreateLoad(castedPointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="91" mnemonic="loadInt32FromMemory" kind="operation">        <name>Load I32 from Memory</name>        <description>Loads an I32 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = *((int32_t*)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM32: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int32AtPointer: pointer.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt32PtrTy(builder.getContext()));            value = builder.CreateLoad(castedPointer);        </semantic>    </instruction>    <instruction opcode="92" mnemonic="loadInt64FromMemory" kind="operation">        <name>Load I64 from Memory</name>        <description>Loads an I64 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self MoveM32: 0 r: pointer R: valueLow.            self MoveM32: 4 r: pointer R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveM64: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt64PtrTy(builder.getContext()));            value = builder.CreateLoad(castedPointer);        </semantic>        <semantic language="C/Interpreter">            value = *((int64_t*)pointer);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int64AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="93" mnemonic="loadInt8FromMemory" kind="operation">        <name>Load I8 from Memory</name>        <description>Loads an I8 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = *((int8_t*)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM8: 0 r: pointer R: value.            self SignExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int8AtPointer: pointer.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateSExt(builder.CreateLoad(pointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="94" mnemonic="loadLocalAddress" kind="operation">        <name>Load local address</name>        <description>It loads a local variable address in the stack</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="pointer" allocate="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            pointer := self basePointer + baseOffset.        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="C/Interpreter">            pointer = basePointer + baseOffset;        </semantic>        <semantic language="C++/LLVM">            pointer = getLocalPointer(baseOffset);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self framePointerOfNativeLocal: baseOffset in: localFP.        </semantic>    </instruction>    <instruction opcode="95" mnemonic="loadLocalFloat32" kind="operation">        <name>Load single precision float from stack</name>        <description>It loads a single precision float from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <float32 name="floatValue" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            floatValue = *((float*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg Rs: floatValue.			self ssPushRegisterSingleFloat: floatValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            floatValue := stackPages singleFloatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getFloatTy());            floatValue = builder.CreateLoad(pointer);        </semantic>    </instruction>    <instruction opcode="96" mnemonic="loadLocalFloat64" kind="operation">        <name>Load double precision float from stack</name>        <description>It loads a double precision float from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <float64 name="doubleValue" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            doubleValue = *((double*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM64: 0 r: TempReg Rd: doubleValue.			self ssPushRegisterDoubleFloat: doubleValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            doubleValue := stackPages floatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getDoubleTy());            doubleValue = builder.CreateLoad(pointer);        </semantic>    </instruction>    <instruction opcode="97" mnemonic="loadLocalInt16" kind="operation">        <name>Load I16 from stack</name>        <description>It Loads an U16 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            value = (int32_t)*((int16_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM16: 0 r: TempReg R: value.            self SignExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int16AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt16Ty());            value = builder.CreateSExt(builder.CreateLoad(pointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="98" mnemonic="loadLocalInt32" kind="operation">        <name>Load I32 from stack</name>        <description>It Loads an U32 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            value = (int32_t)*((int32_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int32AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt32Ty());            value = builder.CreateLoad(pointer);        </semantic>    </instruction>    <instruction opcode="99" mnemonic="loadLocalInt64" kind="operation">        <name>Load I64 from stack</name>        <description>It Loads an I64 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: valueLow.            self MoveM32: 4 r: TempReg R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM64: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt64Ty());            value = builder.CreateLoad(pointer);        </semantic>        <semantic language="C/Interpreter">            value = (int64_t)*((int64_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int64AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="100" mnemonic="loadLocalInt8" kind="operation">        <name>Load I8 from stack</name>        <description>It Loads an U8 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            value = (int32_t)*((int8_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM8: 0 r: TempReg R: value.            self SignExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int8AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8Ty());            value = builder.CreateSExt(builder.CreateLoad(pointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="101" mnemonic="loadLocalPointer" kind="operation">        <name>Load pointer from stack</name>        <description>It loads a pointer from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="pointerResult" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            pointerResult = (void*)*((void**)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveMw: 0 r: TempReg R: pointerResult.			self ssPushNativeRegister: pointerResult.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointerResult := stackPages pointerAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8PtrTy());            pointerResult = builder.CreateLoad(pointer);        </semantic>    </instruction>    <instruction opcode="102" mnemonic="loadLocalUInt16" kind="operation">        <name>Load U16 from stack</name>        <description>It Loads an U16 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            value = (uint32_t)*((uint16_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM16: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint16AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt16Ty());            value = builder.CreateZExt(builder.CreateLoad(pointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="103" mnemonic="loadLocalUInt32" kind="operation">        <name>Load U32 from stack</name>        <description>It Loads an U32 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            value = (uint32_t)*((uint32_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint32AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt32Ty());            value = builder.CreateLoad(pointer);        </semantic>    </instruction>    <instruction opcode="104" mnemonic="loadLocalUInt64" kind="operation">        <name>Load U8 from stack</name>        <description>It Loads an U8 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: valueLow.            self MoveM32: 4 r: TempReg R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM64: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt64Ty());            value = builder.CreateLoad(pointer);        </semantic>        <semantic language="C/Interpreter">            value = (uint64_t)*((uint64_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint64AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="105" mnemonic="loadLocalUInt8" kind="operation">        <name>Load U8 from stack</name>        <description>It Loads an U8 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            value = (uint32_t)*((uint8_t*)(basePointer + baseOffset));        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM8: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint8AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8Ty());            value = builder.CreateZExt(builder.CreateLoad(pointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="106" mnemonic="loadPointerFromMemory" kind="operation">        <name>Load Pointer from Memory</name>        <description>Loads a pointer from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <pointer name="pointerResult" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            pointerResult := pointer readWord.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveMw: 0 r: pointer R: pointerResult.			self ssPushNativeRegister: pointerResult.        </semantic>        <semantic language="C/Interpreter">            pointerResult = *((void**)pointer);        </semantic>        <semantic language="C++/LLVM">            llvm::Type *pointerType = llvm::PointerType::getUnqual(llvm::Type::getInt8PtrTy(builder.getContext()));            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, pointerType);            pointerResult = builder.CreateLoad(castedPointer);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointerResult := self pointerAtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="107" mnemonic="loadUInt16FromMemory" kind="operation">        <name>Load U16 from Memory</name>        <description>It loads an U16 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = (uint32_t)*((uint16_t*)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM16: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint16AtPointer: pointer.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt16PtrTy(builder.getContext()));            value = builder.CreateZExt(builder.CreateLoad(castedPointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="108" mnemonic="loadUInt32FromMemory" kind="operation">        <name>Load U32 from Memory</name>        <description>Loads an U32 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            value := pointer readWord.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM32: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="C/Interpreter">            value = *((uint32_t*)pointer);        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt32PtrTy(builder.getContext()));            value = builder.CreateLoad(castedPointer);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint32AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="109" mnemonic="loadUInt64FromMemory" kind="operation">        <name>Load U64 from Memory</name>        <description>Loads an U64 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self MoveM32: 0 r: pointer R: valueLow.            self MoveM32: 4 r: pointer R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveM64: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt64PtrTy(builder.getContext()));            value = builder.CreateLoad(castedPointer);        </semantic>        <semantic language="C/Interpreter">            value = *((uint64_t*)pointer);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint64AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="110" mnemonic="loadUInt8FromMemory" kind="operation">        <name>Load U8 from Memory</name>        <description>Loads an U8 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = (uint32_t)*((uint8_t*)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            self MoveM8: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint8AtPointer: pointer.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateZExt(builder.CreateLoad(pointer), builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="111" mnemonic="localFrameSize" kind="metadata">        <name>Local Frame Size</name>        <description>This instruction is used to describe the size of the local frame.</description>        <arguments>            <extend-a name="size" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Pharo/VirtualCPU">            &quot;Do nothing.&quot;        </semantic>        <semantic language="Smalltalk/Cog">            self assert: needsFrame.            hasNativeFrame := true.            "Fetch the stack"            self MoveAw: coInterpreter nativeStackPointerAddress R: TempReg.            self AddCq: 1 R: TempReg.            self MoveR: TempReg Mw: self frameOffsetOfPreviousNativeStackPointer r: FPReg.            "Store the frame pointer"            self SubCq: size R: TempReg.            self MoveR: TempReg Mw: self frameOffsetOfNativeFramePointer r: FPReg.            "Store the new stack pointer"            self MoveR: TempReg Mw: self frameOffsetOfNativeStackPointer r: FPReg.            "Allocate space for the locals"            self SubCq: 1 + coInterpreter defaultNativeStackFrameSize R: TempReg.            self MoveR: TempReg Aw: coInterpreter nativeStackPointerAddress.                    </semantic>        <semantic language="C/Interpreter">            /* Do nothing. */        </semantic>        <semantic language="C++/LLVM">            // Do nothing.        </semantic>        <semantic locals="taggedPointer" language="Smalltalk/StackInterpreter">            "Store the previous stack pointer"            self nativePreviousStackPointerIn: localFP put: nativeStackPointer + 1.            "Make the frame pointer"            nativeStackPointer := nativeStackPointer - size.            self nativeFramePointerIn: localFP put: nativeStackPointer + 1.            "Set the stack pointer"            nativeSP := nativeStackPointer + 1.            self nativeStackPointerIn: localFP put: nativeStackPointer + 1.            "Reserve space for the native stack"            nativeStackPointer := nativeStackPointer - self defaultNativeStackFrameSize.        </semantic>    </instruction>    <instruction opcode="112" mnemonic="lockRegisters" kind="operation">        <name>Lock Registers</name>        <description>            Locks the CPU register. This tells the register allocator that the            following instructions are going to modify some explicit CPU registers.        </description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.        </semantic>    </instruction>    <instruction opcode="113" mnemonic="lockVM" kind="operation">        <name>Lock VM</name>        <description>Locks the VM to the current thread.</description>        <arguments />        <stack-arguments />         <stack-results />        <semantic language="C/Interpreter">            /* TODO */        </semantic>        <semantic language="Slang">            &quot;TODO&quot;        </semantic>    </instruction>    <instruction opcode="114" mnemonic="malloc32" kind="operation">        <name>Malloc</name>        <description>            Allocates memory from heap        </description>        <arguments />        <stack-arguments>            <int32 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="C/Interpreter">            pointer = malloc(size);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            size ~= ReceiverResultReg ifTrue: [self MoveR: size R: ReceiverResultReg ].            self CallRT: ceMallocTrampoline.            self MoveR: TempReg R: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self malloc: size.        </semantic>        <semantic language="C++/LLVM">            pointer = builder.CreateCall(getMallocFunction(), size);        </semantic>    </instruction>    <instruction opcode="115" mnemonic="malloc64" kind="operation">        <name>Malloc</name>        <description>            Allocates memory from heap        </description>        <arguments />        <stack-arguments>            <int64 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            sizeLow ~= ReceiverResultReg ifTrue: [self MoveR: sizeLow R: ReceiverResultReg ].            self CallRT: ceMallocTrampoline.            self MoveR: TempReg R: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            size ~= ReceiverResultReg ifTrue: [self MoveR: size R: ReceiverResultReg ].            self CallRT: ceMallocTrampoline.            self MoveR: TempReg R: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="C++/LLVM">            pointer = builder.CreateCall(getMallocFunction(), size);        </semantic>        <semantic language="C/Interpreter">            pointer = malloc(size);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self malloc: size.        </semantic>    </instruction>    <instruction opcode="116" mnemonic="memcpy32" kind="operation">        <name>Copies a block of memory</name>        <description>Copies a block of memory</description>        <arguments />        <stack-arguments>            <pointer name="dest" />            <pointer name="source" />            <int32 name="size" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            memcpy(dest, source, size);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self mem: dest cp: source y: size.        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            backEnd genMemCopy: source to: dest size: size.        </semantic>        <semantic language="C++/LLVM">            builder.CreateMemCpy(dest, source, size, 1);        </semantic>    </instruction>    <instruction opcode="117" mnemonic="memcpy64" kind="operation">        <name>Copies a block of memory</name>        <description>Copies a block of memory</description>        <arguments />        <stack-arguments>            <pointer name="dest" />            <pointer name="source" />            <int64 name="size" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            memcpy(dest, source, size);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self mem: dest cp: source y: size.        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            backEnd genMemCopy: source to: dest size: sizeLow.        </semantic>        <semantic language="C++/LLVM">            builder.CreateMemCpy(dest, source, size, 1);        </semantic>    </instruction>    <instruction opcode="118" mnemonic="memcpyFixed" kind="operation">        <name>Copies a block of memory</name>        <description>Copies a block of memory</description>        <arguments>            <extend-a name="size" />        </arguments>        <stack-arguments>            <pointer name="dest" />            <pointer name="source" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            memcpy(dest, source, size);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self mem: dest cp: source y: size.        </semantic>        <semantic language="Smalltalk/Cog">            size = BytesPerWord ifTrue: [                self MoveMw: 0 r: source R: TempReg.                self MoveR: TempReg Mw: 0 r: dest.            ] ifFalse: [                self ssFlushAll.                backEnd genMemCopy: source to: dest constantSize: size.            ].        </semantic>        <semantic language="C++/LLVM">            builder.CreateMemCpy(dest, source, size, 1);        </semantic>    </instruction>    <instruction opcode="119" mnemonic="moveFloat32ToPhysical" kind="operation">        <name>Move Float32 To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="120" mnemonic="moveFloat64ToPhysical" kind="operation">        <name>Move Float64 Register To Physical Register</name>        <description>Moves the content of a logical register into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="121" mnemonic="moveInt32ToPhysical" kind="operation">        <name>Move Int32  To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="122" mnemonic="moveInt64ToPhysical" kind="operation">        <name>Move Int64 To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="123" mnemonic="movePointerToPhysical" kind="operation">        <name>Move Pointer To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="124" mnemonic="mul32" kind="operation">        <name>Integer Signed Multiplication</name>        <description>Integer multiplication without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := first * second.        </semantic>        <semantic language="Smalltalk/Cog">            self MulR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            result = first * second;        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateMul(first, second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>    </instruction>    <instruction opcode="125" mnemonic="mul64" kind="operation">        <name>Integer Signed Multiplication</name>        <description>Integer multiplication without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = first * second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateMul(first, second);        </semantic>    </instruction>    <instruction opcode="126" mnemonic="neg32" kind="operation">        <name>Integer Negation</name>        <description>Integer negation.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = -value;        </semantic>        <semantic language="Smalltalk/Cog">            self NegateR: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value negated.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateNeg(value);        </semantic>    </instruction>    <instruction opcode="127" mnemonic="neg64" kind="operation">        <name>Integer Negation</name>        <description>Integer negation.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;Two complement negation&quot;            self NotR: valueLow.            self NotR: valueHigh.            self AddCq: 1 R: valueLow.            self AddcCq: 0 R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self NegateR: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateNeg(value);        </semantic>        <semantic language="C/Interpreter">            result = -value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value negated.        </semantic>    </instruction>    <instruction opcode="128" mnemonic="not32" kind="operation">        <name>Bitwise Not</name>        <description>Performs a bitwise not.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = ~value;        </semantic>        <semantic language="Smalltalk/Cog">            self NotR: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitXor: -1.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateNot(value);        </semantic>    </instruction>    <instruction opcode="129" mnemonic="not64" kind="operation">        <name>Bitwise Not</name>        <description>Performs a bitwise not.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self NotR: valueLow.            self NotR: valueHigh.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self NotR: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateNot(value);        </semantic>        <semantic language="C/Interpreter">            result = ~value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitXor: -1.        </semantic>    </instruction>    <instruction opcode="130" mnemonic="or32" kind="operation">        <name>Bitwise Or</name>        <description>Performs a bitwise or operation.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = first | second;        </semantic>        <semantic language="Smalltalk/Cog">            self OrR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitOr: second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateOr(first, second);        </semantic>    </instruction>    <instruction opcode="131" mnemonic="or64" kind="operation">        <name>Bitwise Or</name>        <description>Performs a bitwise or operation.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self OrR: secondLow R: firstLow.            self OrR: secondHigh R: firstHigh.            self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self OrR: second R: first.            self ssPushNativeRegister: first.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateOr(first, second);        </semantic>        <semantic language="C/Interpreter">            result = first | second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitOr: second.        </semantic>    </instruction>    <instruction opcode="132" mnemonic="performCallFloat32" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with Float32 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <float32 name="result"/>        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_FLOAT32((void**)(size_t)function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRs: DPFPReg0.            self ssPushRegisterSingleFloat: DPFPReg0.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Float32Result: result.            self internalizeIPandSP.        </semantic>        <semantic language="C++/LLVM">            result = performCall(builder.getFloatTy(), function);        </semantic>    </instruction>    <instruction opcode="133" mnemonic="performCallFloat64" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with Float64 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <float64 name="result" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_FLOAT64((void**)(size_t)function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRd: DPFPReg0.            self ssPushRegisterDoubleFloat: DPFPReg0.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Float32Result: result.            self internalizeIPandSP.        </semantic>        <semantic language="C++/LLVM">            result = performCall(builder.getDoubleTy(), function);        </semantic>    </instruction>    <instruction opcode="134" mnemonic="performCallIndirectFloat32" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with Float32 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_FLOAT32(function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRs: DPFPReg0.            self ssPushRegisterSingleFloat: DPFPReg0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCall: function Float32Result: result.        </semantic>        <semantic language="C++/LLVM">            self externalizeIPandSP.            result = performCallIndirect(builder.getFloatTy(), function);            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="135" mnemonic="performCallIndirectFloat64" kind="operation">        <name>Perform indirect function call.</name>        <description>It erforms an indirect function with Float64 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_FLOAT64(function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRd: DPFPReg0.            self ssPushRegisterDoubleFloat: DPFPReg0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCall: function Float64Result: result.        </semantic>        <semantic language="C++/LLVM">            self externalizeIPandSP.            result = performCallIndirect(builder.getDoubleTy(), function);            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="136" mnemonic="performCallIndirectInt32" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with I32 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_INT32(function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCall: function Int32Result: result.        </semantic>        <semantic language="C++/LLVM">            self externalizeIPandSP.            result = performCallIndirect(builder.getInt32Ty(), function);            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="137" mnemonic="performCallIndirectInt64" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with I64 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            BytesPerWord = 4 ifTrue: [                self MoveR: backEnd cResultRegisterLow R: ReceiverResultReg.                self MoveR: backEnd cResultRegisterHigh R: Arg0Reg.                self ssPushRegister: ReceiverResultReg secondRegister: Arg0Reg.            ] ifFalse: [                self MoveR: backEnd cResultRegister R: ReceiverResultReg.                self ssPushNativeRegister: ReceiverResultReg.            ].        </semantic>        <semantic language="C++/LLVM">            result = performCallIndirect(builder.getInt64Ty(), function);        </semantic>        <semantic language="C/Interpreter">            DO_CALL_INT64(function, result);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Int64Result: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="138" mnemonic="performCallIndirectPointer" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with pointer result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <pointer name="result" />        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_POINTER(function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function PointerResult: result.            self internalizeIPandSP.        </semantic>        <semantic language="C++/LLVM">            result = performCallIndirect(builder.getInt8PtrTy(), function);        </semantic>    </instruction>    <instruction opcode="139" mnemonic="performCallIndirectStructure" kind="operation">        <name>Perform indirection function call.</name>        <description>It performs an indirect function with structure result.</description>        <arguments>            <extend-a name="structureSize" />        </arguments>        <stack-arguments>            <pointer name="function" />            <pointer name="result" />        </stack-arguments>        <stack-results>            <pointer name="resultPointer" />        </stack-results>        <semantic language="C/Interpreter">            CALL_ARGUMENT_POINTER(result);            DO_CALL_STRUCTURE((void**)(size_t)function, resultPointer, structureSize);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentPointer: result.            self externalizeIPandSP.            self LowcodeInterpreterCall: function StructureResult: resultPointer Size: structureSize.            self internalizeIPandSP.        </semantic>        <semantic language="Smalltalk/Cog/Raw">            "Push the result space"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            "Fetch the function pointer"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            "Call the function"            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            "Fetch the result"            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.        </semantic>        <semantic language="C++/LLVM">            resultPointer = performCallIndirectStructure(result, structureSize, function);        </semantic>    </instruction>    <instruction opcode="140" mnemonic="performCallInt32" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with I32 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="result" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_INT32((void**)(size_t)function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Int32Result: result.            self internalizeIPandSP.        </semantic>        <semantic language="C++/LLVM">            result = performCall(builder.getInt32Ty(), function);        </semantic>    </instruction>    <instruction opcode="141" mnemonic="performCallInt64" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with I64 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="result" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            BytesPerWord = 4 ifTrue: [                self MoveR: backEnd cResultRegisterLow R: ReceiverResultReg.                self MoveR: backEnd cResultRegisterHigh R: Arg0Reg.                self ssPushRegister: ReceiverResultReg secondRegister: Arg0Reg.            ] ifFalse: [                self MoveR: backEnd cResultRegister R: ReceiverResultReg.                self ssPushNativeRegister: ReceiverResultReg.            ].            extA := 0.        </semantic>        <semantic language="C++/LLVM">            result = performCall(builder.getInt64Ty(), function);        </semantic>        <semantic language="C/Interpreter">            DO_CALL_INT64((void**)(size_t)function, result);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Int64Result: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="142" mnemonic="performCallPointer" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with pointer result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="result" allocate="true" />        </stack-results>        <semantic language="C/Interpreter">            DO_CALL_POINTER((void**)(size_t)function, result);        </semantic>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function PointerResult: result.            self internalizeIPandSP.        </semantic>        <semantic language="C++/LLVM">            result = performCall(builder.getInt8PtrTy(), function);        </semantic>    </instruction>    <instruction opcode="143" mnemonic="performCallStructure" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with structure result</description>        <arguments>            <extend-a name="function" />            <extend-b name="structureSize" />        </arguments>        <stack-arguments>            <pointer name="result" />        </stack-arguments>        <stack-results>            <pointer name="resultPointer" />        </stack-results>        <semantic language="C/Interpreter">            CALL_ARGUMENT_POINTER(result);            DO_CALL_STRUCTURE((void**)(size_t)function, resultPointer, structureSize);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentPointer: result.            self externalizeIPandSP.            self LowcodeInterpreterCall: function StructureResult: resultPointer Size: structureSize.            self internalizeIPandSP.        </semantic>        <semantic language="Smalltalk/Cog/Raw">            "Push the result space"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            "Call the function"            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            "Fetch the result"            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.            extB := 0.        </semantic>        <semantic language="C++/LLVM">            resultPointer = performCallStructure(result, structureSize, function);        </semantic>    </instruction>    <instruction opcode="144" mnemonic="plaftormCode" kind="operation">        <name>Platform Code</name>        <description>            Returns the platform code        </description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="code" />        </stack-results>        <semantic language="C/Interpreter">            UNIMPLEMENTED();        </semantic>    </instruction>    <instruction opcode="145" mnemonic="pointerAddOffset32" kind="operation">        <name>Adds an offset to a pointer</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int32 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := base + offset.        </semantic>        <semantic language="Smalltalk/Cog">            self AddR: offset R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="C/Interpreter">            result = ((char*)base) + offset;        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateGEP(base, offset);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := base + offset.        </semantic>    </instruction>    <instruction opcode="146" mnemonic="pointerAddOffset64" kind="operation">        <name>Adds an offset to a pointer</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int64 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/64">            self AddR: offset R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="Smalltalk/Cog/32">            self AddR: offsetLow R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="Pharo/VirtualCPU">            result := base + offset.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateGEP(base, offset);        </semantic>        <semantic language="C/Interpreter">            result = ((char*)base) + offset;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := base + offset.        </semantic>    </instruction>    <instruction opcode="147" mnemonic="pointerEqual" kind="operation">        <name>Pointer Equality</name>        <description>Pointer equality comparison.</description>        <arguments />        <stack-arguments>            <pointer name="first" />            <pointer name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = first == second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpEQ(first, second));        </semantic>    </instruction>    <instruction opcode="148" mnemonic="pointerNotEqual" kind="operation">        <name>Pointer Not Equality</name>        <description>Pointer not equality comparison.</description>        <arguments />        <stack-arguments>            <pointer name="first" />            <pointer name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = first != second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpNE(first, second));        </semantic>    </instruction>    <instruction opcode="149" mnemonic="pointerToInt32" kind="operation">        <name>Pointer to Int32</name>        <description>It converts a pointer into a 32-bit integer.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (int32_t)((uintptr_t)pointer);        </semantic>        <semantic language="Smalltalk/Cog">            &quot;TODO: Perform a NOP here&quot;            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: pointer to: 'uintptr_t'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreatePtrToInt(pointer, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="150" mnemonic="pointerToInt64" kind="operation">        <name>Pointer to Int64</name>        <description>It converts a pointer into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self MoveR: pointer R: resultLow.            self MoveCq: 0 R: resultHigh.            self ssPushRegister: resultLow secondRegister: resultHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreatePtrToInt(pointer, builder.getInt64Ty());        </semantic>        <semantic language="C/Interpreter">            result = (int64_t)((uintptr_t)pointer);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: pointer to: 'uintptr_t'.        </semantic>    </instruction>    <instruction opcode="151" mnemonic="popFloat32" kind="operation">        <name>Pop Float32</name>        <description>It removes the Float32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="152" mnemonic="popFloat64" kind="operation">        <name>Pop Float64</name>        <description>It removes the Float64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="153" mnemonic="popInt32" kind="operation">        <name>Pop Int32</name>        <description>It removes the Int32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="154" mnemonic="popInt64" kind="operation">        <name>Pop Int64</name>        <description>It removes the Int64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="155" mnemonic="popPointer" kind="operation">        <name>Pop Pointer</name>        <description>It removes the Pointer present in the top of the stack</description>        <arguments />        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="156" mnemonic="pushConstantUInt32" kind="operation">        <name>Push a 32-bit integer constant</name>        <description>Pushes a 32-bit integer constant.</description>        <arguments>            <extend-a name="constant" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word: constant.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: constant.        </semantic>        <semantic language="C/Interpreter">            result = constant;        </semantic>        <semantic language="C++/LLVM">            result = builder.getInt32(constant);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := constant.        </semantic>    </instruction>    <instruction opcode="157" mnemonic="pushConstantUInt64" kind="operation">        <name>Push a 64-bit integer constant</name>        <description>Pushes a 64-bit integer constant.</description>        <arguments>            <extend-a name="constant" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word: constant.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt64: constant.        </semantic>        <semantic language="C/Interpreter">            result = constant;        </semantic>        <semantic language="C++/LLVM">            result = builder.getInt64(0);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := constant.        </semantic>    </instruction>    <instruction opcode="158" mnemonic="pushNullPointer" kind="operation">        <name>Push Null Pointer</name>        <description>It pushes a null pointer</description>        <arguments />        <stack-arguments />        <stack-results>            <pointer name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word0.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantNativePointer: 0.        </semantic>        <semantic language="C/Interpreter">            result = 0;        </semantic>        <semantic language="C++/LLVM">            result = llvm::ConstantPointerNull::get(builder.getInt8PtrTy());        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.        </semantic>    </instruction>    <instruction opcode="159" mnemonic="pushOne32" kind="operation">        <name>Push one constant 32-bit integer</name>        <description>Pushes a 32 bit one constant</description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word: 1.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: 1.        </semantic>        <semantic language="C/Interpreter">            result = 1;        </semantic>        <semantic language="C++/LLVM">            result = builder.getInt32(1);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.        </semantic>    </instruction>    <instruction opcode="160" mnemonic="pushOne64" kind="operation">        <name>Push one constant 64-bit integer</name>        <description>Pushes a 64 bit one constant</description>        <arguments />        <stack-arguments />        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word: 1.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt64: 1.        </semantic>        <semantic language="C/Interpreter">            result = 1;        </semantic>        <semantic language="C++/LLVM">            result = builder.getInt64(1);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.        </semantic>    </instruction>    <instruction opcode="161" mnemonic="pushOneFloat32" kind="operation">        <name>Push a single precision one constant</name>        <description>It pushes a single precision float of one</description>        <arguments />        <stack-arguments />        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = 1;        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat32: 1.0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.0.        </semantic>        <semantic language="C++/LLVM">            result = llvm::ConstantFP::get(builder.getFloatTy(), 1);        </semantic>    </instruction>    <instruction opcode="162" mnemonic="pushOneFloat64" kind="operation">        <name>Push a single precision one constant</name>        <description>It pushes a single precision float of one</description>        <arguments />        <stack-arguments />        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = 1;        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat64: 1.0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.0.        </semantic>        <semantic language="C++/LLVM">            result = llvm::ConstantFP::get(builder.getDoubleTy(), 1);        </semantic>    </instruction>    <instruction opcode="163" mnemonic="pushPhysicalFloat32" kind="operation">        <name>Push Float32 from physical register</name>        <description>Pushes an Float32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <float32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="164" mnemonic="pushPhysicalFloat64" kind="operation">        <name>Push Float64 from physical register</name>        <description>Pushes an Float64 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <float64 name="value" />        </stack-results>        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="165" mnemonic="pushPhysicalInt32" kind="operation">        <name>Push Int32 from physical register</name>        <description>Pushes an Int32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="166" mnemonic="pushPhysicalInt64" kind="operation">        <name>Push Int64 from physical register</name>        <description>Pushes an Int32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="167" mnemonic="pushPhysicalPointer" kind="operation">        <name>Push Pointer from physical register</name>        <description>Pushes a pointer from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="pointerValue" />        </stack-results>        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>    </instruction>    <instruction opcode="168" mnemonic="pushSessionIdentifier" kind="operation">        <name>Pushes the unique session identifier</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            value := self sessionIdentifier.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: coInterpreter getThisSessionID.        </semantic>        <semantic language="C/Interpreter">            if(!Lowcode_sessionInitialized)                Lowcode_initializeSession();            value = Lowcode_sessionIdentifier;        </semantic>        <semantic language="C++/LLVM">            value = builder.getInt32(LowcodeLLVMContext::get().getSessionIdentifier());        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self getThisSessionID.        </semantic>    </instruction>    <instruction opcode="169" mnemonic="pushZero32" kind="operation">        <name>Pushes zero constant</name>        <description>Pushes a 32 bit zero</description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word0.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: 0.        </semantic>        <semantic language="C/Interpreter">            result = 0;        </semantic>        <semantic language="C++/LLVM">            result = builder.getInt32(0);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.        </semantic>    </instruction>    <instruction opcode="170" mnemonic="pushZero64" kind="operation">        <name>Pushes zero constant</name>        <description>Pushes a 64 bit zero</description>        <arguments />        <stack-arguments />        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word0.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt64: 0.        </semantic>        <semantic language="C/Interpreter">            result = 0;        </semantic>        <semantic language="C++/LLVM">            result = builder.getInt64(0);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.        </semantic>    </instruction>    <instruction opcode="171" mnemonic="pushZeroFloat32" kind="operation">        <name>Pushes a zero single precision float constant</name>        <description>It pushes a single precision float zero</description>        <arguments />        <stack-arguments />        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := vcpu word0.        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat32: 0.0.        </semantic>        <semantic language="C/Interpreter">            result = 0;        </semantic>        <semantic language="C++/LLVM">            result = llvm::ConstantFP::get(builder.getFloatTy(), 0);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.0.        </semantic>    </instruction>    <instruction opcode="172" mnemonic="pushZeroFloat64" kind="operation">        <name>Pushes a zero single precision float constant</name>        <description>It pushes a single precision float zero</description>        <arguments />        <stack-arguments />        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = 0;        </semantic>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat64: 0.0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.0.        </semantic>        <semantic language="C++/LLVM">            result = llvm::ConstantFP::get(builder.getDoubleTy(), 0);        </semantic>    </instruction>    <instruction opcode="173" mnemonic="rem32" kind="operation">        <name>Integer Signed Remainder</name>        <description>Integer signed remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first % second;        </semantic>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: second Rem: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first \\ second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSRem(first, second);        </semantic>    </instruction>    <instruction opcode="174" mnemonic="rem64" kind="operation">        <name>Integer Signed Remainder</name>        <description>Integer signed remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = first % second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first \\ second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSRem(first, second);        </semantic>    </instruction>    <instruction opcode="175" mnemonic="rightShift32" kind="operation">        <name>Right Shift</name>        <description>Performs a right shifting.</description>        <arguments />        <stack-arguments>            <int32 name="value" />            <int32 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = ((uint32_t)value) &gt;&gt; ((uint32_t)shiftAmount);        </semantic>        <semantic language="Smalltalk/Cog">            self LogicalShiftRightR: shiftAmount R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateLShr(value, shiftAmount);        </semantic>    </instruction>    <instruction opcode="176" mnemonic="rightShift64" kind="operation">        <name>Right Shift</name>        <description>Performs a right shifting.</description>        <arguments />        <stack-arguments>            <int64 name="value" />            <int64 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = ((uint64_t)value) &gt;&gt; ((uint64_t)shiftAmount);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateLShr(value, shiftAmount);        </semantic>    </instruction>    <instruction opcode="177" mnemonic="signExtend32From16" kind="operation">        <name>Sign Extend 16-bit</name>        <description>Sign extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (int16_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self SignExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'signed short'.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());            result = builder.CreateSExt(small, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="178" mnemonic="signExtend32From8" kind="operation">        <name>Sign Extend 8-bit</name>        <description>Sign extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (int8_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self SignExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'signed char'.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());            result = builder.CreateSExt(small, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="179" mnemonic="signExtend64From16" kind="operation">        <name>Sign Extend 16-bit</name>        <description>Sign extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic locals="isNegative cont" language="Smalltalk/Cog/32">            self SignExtend16R: valueLow R: valueLow.            &quot;Check the sign to set the high word&quot;            self CmpCq: 0 R: valueLow.            &quot;Positive&quot;            isNegative := self JumpLess: 0.            self MoveCq: 0 R: valueHigh.            cont := self Jump: 0.            &quot;Negative&quot;            isNegative jmpTarget: (self MoveCq: -1 R: valueHigh).            cont jmpTarget: self Label.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SignExtend16R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());            result = builder.CreateSExt(small, builder.getInt64Ty());        </semantic>        <semantic language="C/Interpreter">            result = (int16_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'int16_t'.        </semantic>    </instruction>    <instruction opcode="180" mnemonic="signExtend64From32" kind="operation">        <name>Sign Extend 32-bit</name>        <description>Sign extends a 32 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic locals="isNegative cont" language="Smalltalk/Cog/32">            self MoveR: value R: resultLow.            &quot;Check the sign to set the high word&quot;            self CmpCq: 0 R: value.            &quot;Positive&quot;            isNegative := self JumpLess: 0.            self MoveCq: 0 R: resultHigh.            cont := self Jump: 0.            &quot;Negative&quot;            isNegative jmpTarget: (self MoveCq: -1 R: resultHigh).            cont jmpTarget: self Label.            self ssPushRegister: resultLow secondRegister: resultHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SignExtend32R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSExt(value, builder.getInt64Ty());        </semantic>        <semantic language="C/Interpreter">            result = (int32_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'int32_t'.        </semantic>    </instruction>    <instruction opcode="181" mnemonic="signExtend64From8" kind="operation">        <name>Sign Extend 8-bit</name>        <description>Sign extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic locals="isNegative cont" language="Smalltalk/Cog/32">            self SignExtend8R: valueLow R: valueLow.            &quot;Check the sign to set the high word&quot;            self CmpCq: 0 R: valueLow.            &quot;Positive&quot;            isNegative := self JumpLess: 0.            self MoveCq: 0 R: valueHigh.            cont := self Jump: 0.            &quot;Negative&quot;            isNegative jmpTarget: (self MoveCq: -1 R: valueHigh).            cont jmpTarget: self Label.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend16R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());            result = builder.CreateSExt(small, builder.getInt64Ty());        </semantic>        <semantic language="C/Interpreter">            result = (int8_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'signed char'.        </semantic>    </instruction>    <instruction opcode="182" mnemonic="storeFloat32ToMemory" kind="operation">        <name>Store Float32 in memory</name>        <description>Stores a Float32 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <float32 name="floatValue" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((float*)pointer) = floatValue;        </semantic>        <semantic language="Smalltalk/Cog">            self MoveRs: floatValue M32: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self singleFloatAtPointer: pointer put: floatValue.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getFloatPtrTy(builder.getContext()));            builder.CreateStore(floatValue, castedPointer);        </semantic>    </instruction>    <instruction opcode="183" mnemonic="storeFloat64ToMemory" kind="operation">        <name>Store Float64 in memory</name>        <description>Stores a Float64 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <float64 name="doubleValue" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((double*)pointer) = doubleValue;        </semantic>        <semantic language="Smalltalk/Cog">            self MoveRd: doubleValue M64: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self floatAtPointer: pointer put: doubleValue.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getDoublePtrTy(builder.getContext()));            builder.CreateStore(doubleValue, castedPointer);        </semantic>    </instruction>    <instruction opcode="184" mnemonic="storeInt16ToMemory" kind="operation">        <name>Store UInt16 in memory</name>        <description>Stores an U16 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((int16_t*)pointer) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self MoveR: TempReg M16: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int16AtPointer: pointer put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedValue = builder.CreateTrunc(value, builder.getInt16Ty());            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt16PtrTy(builder.getContext()));            builder.CreateStore(castedValue, castedPointer);        </semantic>    </instruction>    <instruction opcode="185" mnemonic="storeInt32ToMemory" kind="operation">        <name>Store Int32 in memory</name>        <description>Stores an I32 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((int32_t*)pointer) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: value M32: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int32AtPointer: pointer put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt32PtrTy(builder.getContext()));            builder.CreateStore(value, castedPointer);        </semantic>    </instruction>    <instruction opcode="186" mnemonic="storeInt64ToMemory" kind="operation">        <name>Store Int64 in memory</name>        <description>It stores an I64 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self MoveR: valueLow M32: 0 r: pointer.            self MoveR: valueHigh M32: 4 r: pointer.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveR: value M64: 0 r: pointer.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt64PtrTy(builder.getContext()));            builder.CreateStore(value, castedPointer);        </semantic>        <semantic language="C/Interpreter">            *((int64_t*)pointer) = value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int64AtPointer: pointer put: value.        </semantic>    </instruction>    <instruction opcode="187" mnemonic="storeInt8ToMemory" kind="operation">        <name>Store UInt8 in memory</name>        <description>Stores an U8 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((int8_t*)pointer) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self MoveR: TempReg M8: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int8AtPointer: pointer put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *castedValue = builder.CreateTrunc(value, builder.getInt8Ty());            builder.CreateStore(castedValue, pointer);        </semantic>    </instruction>    <instruction opcode="188" mnemonic="storeLocalFloat32" kind="operation">        <name>Store single precision float in the stack frame</name>        <description>It stores a single precision float in the stack frame..</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((float*)(basePointer + baseOffset)) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveRs: value M32: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages singleFloatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getFloatTy());            builder.CreateStore(value, pointer);        </semantic>    </instruction>    <instruction opcode="189" mnemonic="storeLocalFloat64" kind="operation">        <name>Store double precision float in the stack frame</name>        <description>It stores a double precision float in the stack frame.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((double*)(basePointer + baseOffset)) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveRd: value M64: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages floatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getDoubleTy());            builder.CreateStore(value, pointer);        </semantic>    </instruction>    <instruction opcode="190" mnemonic="storeLocalInt16" kind="operation">        <name>Store I16 to stack frame</name>        <description>It stores an I16 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((int16_t*)(basePointer + baseOffset)) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self loadNativeLocalAddress: baseOffset to: value.            self MoveR: TempReg M16: 0 r: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages int16AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt16Ty());            builder.CreateStore(builder.CreateTrunc(value, builder.getInt16Ty()), pointer);        </semantic>    </instruction>    <instruction opcode="191" mnemonic="storeLocalInt32" kind="operation">        <name>Store I32 to stack frame</name>        <description>It stores an I32 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((int32_t*)(basePointer + baseOffset)) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveR: value M32: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages int32AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt32Ty());            builder.CreateStore(value, pointer);        </semantic>    </instruction>    <instruction opcode="192" mnemonic="storeLocalInt64" kind="operation">        <name>Store I64 to stack frame</name>        <description>It stores an I64 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveR: valueLow M32: 0 r: TempReg.            self MoveR: valueHigh M32: 4 r: TempReg.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveR: value M64: 0 r: TempReg.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt64Ty());            builder.CreateStore(value, pointer);        </semantic>        <semantic language="C/Interpreter">            *((int64_t*)(basePointer + baseOffset)) = value;        </semantic>        <semantic language="Smalltalk/StackInterpreter/Raw">            &lt;var: #valueInt64 type: #'sqLong'&gt;            |valueInt64|            BytesPerWord = 4 ifTrue: [                self lowcodeStoreLocalInt64Workaround: extA in: localFP sp: localSP.            ] ifFalse: [                valueInt64 := self internalPopStackInt64.                stackPages int64AtPointer: (self framePointerOfNativeLocal: extA in: localFP) put: valueInt64.            ].            extA := 0.        </semantic>    </instruction>    <instruction opcode="193" mnemonic="storeLocalInt8" kind="operation">        <name>Store I8 to stack frame</name>        <description>It stores an I8 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((int8_t*)(basePointer + baseOffset)) = value;        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self loadNativeLocalAddress: baseOffset to: value.            self MoveR: TempReg M8: 0 r: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages int8AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8Ty());            builder.CreateStore(builder.CreateTrunc(value, builder.getInt8Ty()), pointer);        </semantic>    </instruction>    <instruction opcode="194" mnemonic="storeLocalPointer" kind="operation">        <name>Store pointer in the stack frame</name>        <description>It stores a pointer in the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            *((void**)(basePointer + baseOffset)) = pointerValue;        </semantic>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveR: pointerValue Mw: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages pointerAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: pointerValue.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8PtrTy());            builder.CreateStore(pointerValue, pointer);        </semantic>    </instruction>    <instruction opcode="195" mnemonic="storePointerToMemory" kind="operation">        <name>Store a pointer in memory</name>        <description>Stores pointer int the memory.</description>        <arguments />        <stack-arguments>            <pointer name="memoryPointer" />            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU">            memoryPointer writeWord: value.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveR: pointerValue Mw: 0 r: memoryPointer.        </semantic>        <semantic language="C/Interpreter">            *((void**)memoryPointer) = pointerValue;        </semantic>        <semantic language="C++/LLVM">            llvm::Type *pointerType = llvm::PointerType::getUnqual(llvm::Type::getInt8PtrTy(builder.getContext()));            llvm::Value *castedPointer = builder.CreatePointerCast(memoryPointer, pointerType);            builder.CreateStore(pointerValue, castedPointer);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self pointerAtPointer: memoryPointer put: pointerValue.        </semantic>    </instruction>    <instruction opcode="196" mnemonic="sub32" kind="operation">        <name>Integer Subtraction</name>        <description>Integer subtraction without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := first - second.        </semantic>        <semantic language="Smalltalk/Cog">            self SubR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            result = first - second;        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSub(first, second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>    </instruction>    <instruction opcode="197" mnemonic="sub64" kind="operation">        <name>Integer Subtraction</name>        <description>Integer subtraction without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self SubR: secondLow R: firstLow.            self SubbR: secondHigh R: firstHigh.			self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SubR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateSub(first, second);        </semantic>        <semantic language="C/Interpreter">            result = first - second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>    </instruction>    <instruction opcode="198" mnemonic="truncate32To16" kind="operation">        <name>Truncate 32-bit to 16-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint16_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self AndCq: 16rFFFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFFFF.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAnd(value, 0xFFFF);        </semantic>    </instruction>    <instruction opcode="199" mnemonic="truncate32To8" kind="operation">        <name>Truncate 32-bit to 8-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint8_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self AndCq: 16rFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFF.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAnd(value, 0xFF);        </semantic>    </instruction>    <instruction opcode="200" mnemonic="truncate64To16" kind="operation">        <name>Truncate 64-bit to 16-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AndCq: 16rFFFF R: valueLow.            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndCq: 16rFFFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAnd(builder.CreateTrunc(value, builder.getInt32Ty()), 0xFFFF);        </semantic>        <semantic language="C/Interpreter">            result = (uint16_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFFFF.        </semantic>    </instruction>    <instruction opcode="201" mnemonic="truncate64To32" kind="operation">        <name>Truncate 64-bit to 32-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndCq: 16rFFFFFFFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateTrunc(value, builder.getInt32Ty());        </semantic>        <semantic language="C/Interpreter">            result = (uint32_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFFFFFFFF.        </semantic>    </instruction>    <instruction opcode="202" mnemonic="truncate64To8" kind="operation">        <name>Truncate 64-bit to 8-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AndCq: 16rFF R: valueLow.            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndCq: 16rFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateAnd(builder.CreateTrunc(value, builder.getInt32Ty()), 0xFF);        </semantic>        <semantic language="C/Interpreter">            result = (uint8_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFF.        </semantic>    </instruction>    <instruction opcode="203" mnemonic="udiv32" kind="operation">        <name>Integer Unsigned division</name>        <description>Integer unsigned division without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := first / second.        </semantic>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: first Rem: second.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            result = ((uint32_t)first) / ((uint32_t)second);        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateUDiv(first, second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') //                        (self cCoerce: second to: 'unsigned int').        </semantic>    </instruction>    <instruction opcode="204" mnemonic="udiv64" kind="operation">        <name>Integer Unsigned division</name>        <description>Integer unsigned division without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = ((uint64_t)first) / ((uint64_t)second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'uint64_t') //                        (self cCoerce: second to: 'uint64_t').        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateUDiv(first, second);        </semantic>    </instruction>    <instruction opcode="205" mnemonic="uint32Great" kind="operation">        <name>UInt32 Great Than</name>        <description>UInt32 great than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint32_t)first) &gt; ((uint32_t)second);        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpBelowOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &gt;                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpUGT(first, second));        </semantic>    </instruction>    <instruction opcode="206" mnemonic="uint32GreatEqual" kind="operation">        <name>UInt32 Great or Equal Than</name>        <description>UInt32 great or equal than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint32_t)first) &gt;= ((uint32_t)second);        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpBelow: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &gt;=                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpUGE(first, second));        </semantic>    </instruction>    <instruction opcode="207" mnemonic="uint32Less" kind="operation">        <name>UInt32 Less Than</name>        <description>UInt32 not equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint32_t)first) &lt; ((uint32_t)second);        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpAboveOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &lt;                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpULT(first, second));        </semantic>    </instruction>    <instruction opcode="208" mnemonic="uint32LessEqual" kind="operation">        <name>UInt32 Less or Equal Than</name>        <description>UInt32 less equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint32_t)first) &lt;= ((uint32_t)second);        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpAbove: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &lt;=                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpULE(first, second));        </semantic>    </instruction>    <instruction opcode="209" mnemonic="uint32ToFloat32" kind="operation">        <name>UInt32 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint32_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rs: result.            self ssPushRegisterSingleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'unsigned int') to: 'float'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateUIToFP(value, builder.getFloatTy());        </semantic>    </instruction>    <instruction opcode="210" mnemonic="uint32ToFloat64" kind="operation">        <name>UInt32 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint32_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rd: result.            self ssPushRegisterDoubleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'unsigned int') to: 'double'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateUIToFP(value, builder.getDoubleTy());        </semantic>    </instruction>    <instruction opcode="211" mnemonic="uint64Great" kind="operation">        <name>UInt32 Great Than</name>        <description>UInt64 great than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint64_t)first) &gt; ((uint64_t)second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &gt;                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpUGT(first, second));        </semantic>    </instruction>    <instruction opcode="212" mnemonic="uint64GreatEqual" kind="operation">        <name>UInt64 Great or Equal Than</name>        <description>UInt64 great or equal than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint64_t)first) &gt;= ((uint64_t)second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &gt;=                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpUGE(first, second));        </semantic>    </instruction>    <instruction opcode="213" mnemonic="uint64Less" kind="operation">        <name>UInt64 Less Than</name>        <description>UInt64 not equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint64_t)first) &lt; ((uint64_t)second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &lt;                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpULT(first, second));        </semantic>    </instruction>    <instruction opcode="214" mnemonic="uint64LessEqual" kind="operation">        <name>UInt64 Less or Equal Than</name>        <description>UInt64 less equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = ((uint64_t)first) &lt;= ((uint64_t)second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &lt;=                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpULE(first, second));        </semantic>    </instruction>    <instruction opcode="215" mnemonic="uint64ToFloat32" kind="operation">        <name>UInt64 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint64_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'uint64_t') to: 'float'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateUIToFP(value, builder.getFloatTy());        </semantic>    </instruction>    <instruction opcode="216" mnemonic="uint64ToFloat64" kind="operation">        <name>UInt64 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint64_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'uint64_t') to: 'double'.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateUIToFP(value, builder.getDoubleTy());        </semantic>    </instruction>    <instruction opcode="217" mnemonic="umul32" kind="operation">        <name>Integer Unsigned Multiplication</name>        <description>Integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := first * second.        </semantic>        <semantic language="Smalltalk/Cog">            self MulR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="C/Interpreter">            result = (uint32_t)first * (uint32_t)second;        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateMul(first, second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') *                        (self cCoerce: second to: 'unsigned int').        </semantic>    </instruction>    <instruction opcode="218" mnemonic="umul64" kind="operation">        <name>Integer Unsigned Multiplication</name>        <description>Integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint64_t)first * (uint64_t)second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'uint64_t') *                        (self cCoerce: second to: 'uint64_t').        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateMul(first, second);        </semantic>    </instruction>    <instruction opcode="219" mnemonic="unlockRegisters" kind="operation">        <name>Unlock Registers</name>        <description>            Unlocks the CPU register. This tells the register allocator that the            following instructions don't require specific CPU registers.        </description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            UNSUPPORTED();        </semantic>        <semantic language="Smalltalk/Cog">            &quot;Do nothing for now&quot;        </semantic>    </instruction>    <instruction opcode="220" mnemonic="unlockVM" kind="operation">        <name>Unlock VM</name>        <description>Unlocks the VM from the current thread.</description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="C/Interpreter">            /* TODO */        </semantic>    </instruction>    <instruction opcode="221" mnemonic="urem32" kind="operation">        <name>Integer Unsigned remainder</name>        <description>Integer unsigned remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = ((uint32_t)first) % ((uint32_t)second);        </semantic>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: second Rem: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') \\                        (self cCoerce: second to: 'unsigned int').        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateURem(first, second);        </semantic>    </instruction>    <instruction opcode="222" mnemonic="urem64" kind="operation">        <name>Integer Unsigned remainder</name>        <description>Integer unsigned remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="C/Interpreter">            result = ((uint64_t)first) % ((uint64_t)second);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') \\                        (self cCoerce: second to: 'unsigned int').        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateURem(first, second);        </semantic>    </instruction>    <instruction opcode="223" mnemonic="xor32" kind="operation">        <name>Bitwise Xor</name>        <description>Performs a bitwise xor operation.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = first ^ second;        </semantic>        <semantic language="Smalltalk/Cog">            self XorR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitXor: second.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateXor(first, second);        </semantic>    </instruction>    <instruction opcode="224" mnemonic="xor64" kind="operation">        <name>Bitwise Xor</name>        <description>Performs a bitwise xor operation.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self XorR: secondLow R: firstLow.            self XorR: secondHigh R: firstHigh.            self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self XorR: second R: first.            self ssPushNativeRegister: first.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateXor(first, second);        </semantic>        <semantic language="C/Interpreter">            result = first ^ second;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitXor: second.        </semantic>    </instruction>    <instruction opcode="225" mnemonic="zeroExtend32From16" kind="operation">        <name>Zero Extend 16-bit</name>        <description>Zero extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint16_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ZeroExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint16_t'.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());            result = builder.CreateZExt(small, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="226" mnemonic="zeroExtend32From8" kind="operation">        <name>Zero Extend 8-bit</name>        <description>Zero extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            result = (uint8_t)value;        </semantic>        <semantic language="Smalltalk/Cog">            self ZeroExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint8_t'.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());            result = builder.CreateZExt(small, builder.getInt32Ty());        </semantic>    </instruction>    <instruction opcode="227" mnemonic="zeroExtend64From16" kind="operation">        <name>Sign Extend 16-bit</name>        <description>Sign extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ZeroExtend16R: valueLow R: valueLow.            self MoveCq: 0 R: valueHigh.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend16R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());            result = builder.CreateZExt(small, builder.getInt64Ty());        </semantic>        <semantic language="C/Interpreter">            result = (uint16_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint16_t'.        </semantic>    </instruction>    <instruction opcode="228" mnemonic="zeroExtend64From32" kind="operation">        <name>Sign Extend 32-bit</name>        <description>Sign extends a 32 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self MoveR: value R: resultLow.            self MoveCq: 0 R: resultHigh.            self ssPushRegister: resultLow secondRegister: resultHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend32R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            result = builder.CreateZExt(value, builder.getInt64Ty());        </semantic>        <semantic language="C/Interpreter">            result = (uint32_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint32_t'.        </semantic>    </instruction>    <instruction opcode="229" mnemonic="zeroExtend64From8" kind="operation">        <name>Zero Extend 8-bit</name>        <description>Zero extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ZeroExtend8R: valueLow R: valueLow.            self MoveCq: 0 R: valueHigh.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend8R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());            result = builder.CreateZExt(small, builder.getInt64Ty());        </semantic>        <semantic language="C/Interpreter">            result = (uint8_t)value;        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint8_t'.        </semantic>    </instruction>    <instruction opcode="400" mnemonic="boolean32ToOop" kind="operation">        <name>Boolean to Oop</name>        <description>It converts an integer representing a boolean into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            object = value ? interpreterProxy-&gt;trueObject() : interpreterProxy-&gt;falseObject();        </semantic>        <semantic locals="trueJump cont inst" language="Smalltalk/Cog">            self CmpCq: 0 R: value.            trueJump := self JumpNonZero: 0.            &quot;False&quot;            self annotate: (self MoveCw: objectMemory falseObject R: value) objRef: objectMemory falseObject.            cont := self Jump: 0.            &quot;True&quot;            inst := self MoveCw: objectMemory trueObject R: value.            trueJump jmpTarget: inst.            self annotate: inst objRef: objectMemory trueObject.            cont jmpTarget: self Label.            self ssPushRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := value ~= 0 ifTrue: [ objectMemory trueObject ] ifFalse: [objectMemory falseObject].        </semantic>        <semantic language="C++/LLVM">            llvm::Value *cond = builder.CreateICmpNE(value, builder.getInt32(0));            object = builder.CreateSelect(cond, getTrueOopValue(), getFalseOopValue());        </semantic>    </instruction>    <instruction opcode="401" mnemonic="boolean64ToOop" kind="operation">        <name>Boolean to Oop</name>        <description>It converts an integer representing a boolean into an oop</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic locals="trueJump trueJump2 cont inst" language="Smalltalk/Cog/32">            self OrR: valueLow R: valueHigh.            trueJump := self JumpNonZero: 0.            &quot;False&quot;            self annotate: (self MoveCw: objectMemory falseObject R: valueLow) objRef: objectMemory falseObject.            cont := self Jump: 0.            &quot;True&quot;            inst := self MoveCw: objectMemory trueObject R: valueLow.            trueJump jmpTarget: inst.            self annotate: inst objRef: objectMemory trueObject.            cont jmpTarget: self Label.            self ssPushRegister: valueLow.        </semantic>        <semantic locals="trueJump cont inst" language="Smalltalk/Cog/64">            self CmpCq: 0 R: value.            trueJump := self JumpNonZero: 0.            &quot;False&quot;            self annotate: (self MoveCw: objectMemory falseObject R: value) objRef: objectMemory falseObject.            cont := self Jump: 0.            &quot;True&quot;            inst := self MoveCw: objectMemory trueObject R: value.            trueJump jmpTarget: inst.            self annotate: inst objRef: objectMemory trueObject.            cont jmpTarget: self Label.            self ssPushRegister: value.        </semantic>        <semantic language="C++/LLVM">            llvm::Value *cond = builder.CreateICmpNE(value, builder.getInt64(0));            object = builder.CreateSelect(cond, getTrueOopValue(), getFalseOopValue());        </semantic>        <semantic language="C/Interpreter">            object = value ? interpreterProxy-&gt;trueObject() : interpreterProxy-&gt;falseObject();        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := value ~= 0 ifTrue: [ objectMemory trueObject ] ifFalse: [objectMemory falseObject].        </semantic>    </instruction>    <instruction opcode="402" mnemonic="float32ToOop" kind="operation">        <name>float32 to Opp</name>        <description>It converts a single precision IEEE 754 floating point number into an oop</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;floatObjectOf(value);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcFloat32: value toOop: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self floatObjectOf: value.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;floatObjectOf(builder.CreateFPCast(value, builder.getDoubleTy()));        </semantic>    </instruction>    <instruction opcode="403" mnemonic="float64ToOop" kind="operation">        <name>float64 to Opp</name>        <description>It converts a double precision IEEE 754 floating point number into an oop</description>        <arguments />        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;floatObjectOf(value);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcFloat64: value toOop: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self floatObjectOf: value.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;floatObjectOf(value);        </semantic>    </instruction>    <instruction opcode="404" mnemonic="int32ToOop" kind="operation">        <name>Int32 to Opp</name>        <description>It converts a signed integer into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;signed32BitIntegerFor(value);        </semantic>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcInt32ToOop: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory signed32BitIntegerFor: value.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;signed32BitIntegerFor(value);        </semantic>    </instruction>    <instruction opcode="405" mnemonic="int64ToOop" kind="operation">        <name>Int32 to Opp</name>        <description>It converts a signed 64-bit integer into an oop</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcInt64ToOop: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcInt64ToOop: value.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;signed64BitIntegerFor(value);        </semantic>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;signed64BitIntegerFor(value);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory signed64BitIntegerFor: value.        </semantic>    </instruction>    <instruction opcode="406" mnemonic="pointerToOop" kind="operation">        <name>Pointer to Oop</name>        <description>Encapsulates a pointer in an object</description>        <arguments>            <literal name="pointerClassLiteral" />        </arguments>        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;instantiateClassindexableSize(pointerClassLiteral, sizeof(void*));            CHECK_FAILED();            *((void**)interpreterProxy-&gt;firstIndexableField(object)) = pointer;        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcPointerToOop: pointer class: pointerClassLiteral.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: pointerClassLiteral indexableSize: BytesPerWord.            self pointerAtPointer: (objectMemory firstIndexableField: object) put: pointer.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;instantiateClassindexableSize(pointerClassLiteral, sizeof(void*));            checkFailed();            llvm::Value *content = getLlvmInterpreterProxy()-&gt;firstIndexableField(object);            llvm::Type *pointerType = llvm::PointerType::getUnqual(builder.getInt8PtrTy());            builder.CreateStore(pointer, builder.CreatePointerCast(content, pointerType));        </semantic>    </instruction>    <instruction opcode="407" mnemonic="pointerToOopReinterprer" kind="operation">        <name>Casts Pointer to Oop Reinterpret</name>        <description>Reinterpret casts a pointer into an Oop.        </description>        <warning>Reinterpret casts a pointer into an Oop.        </warning>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            object = (sqInt)pointer;        </semantic>        <semantic language="Smalltalk/Cog">            &quot;TODO: Generate a nop here&quot;            self ssPushRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self cCoerce: pointer to: 'sqInt'.        </semantic>        <semantic language="C++/LLVM">            object = builder.CreatePtrToInt(pointer, LowcodeLLVMContext::get().getSqIntType());        </semantic>    </instruction>    <instruction opcode="408" mnemonic="smallInt32ToOop" kind="operation">        <name>SmallInteger32 to Opp</name>        <description>It converts a small integer into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            object := (value &lt;&lt; (vcpu word: 1)) | (vcpu word: 1).        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genConvertIntegerToSmallIntegerInScratchReg: value.            self ssPushRegister: value.        </semantic>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;integerObjectOf(value);        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;integerObjectOf(value);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory integerObjectOf: value.        </semantic>    </instruction>    <instruction opcode="409" mnemonic="uint32ToOop" kind="operation">        <name>UInt32 to Opp</name>        <description>It converts an unsigned integer into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;positive32BitIntegerFor(value);        </semantic>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcUInt32ToOop: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory positive32BitIntegerFor: value.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;positive32BitIntegerFor(value);        </semantic>    </instruction>    <instruction opcode="410" mnemonic="uint64ToOop" kind="operation">        <name>UInt64 to Opp</name>        <description>It converts an unsigned integer into an oop</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcUInt64ToOop: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcUInt64ToOop: value.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;positive64BitIntegerFor(value);        </semantic>        <semantic language="C/Interpreter">            object = interpreterProxy-&gt;positive64BitIntegerFor(value);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self positive64BitIntegerFor: value.        </semantic>    </instruction>    <instruction opcode="1000" mnemonic="byteSizeOf" kind="operation">        <name>Byte size of object</name>        <description>It tells the number of variable bytes of an object</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;byteSizeOf(object);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcByteSizeOf: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self byteSizeOf: object.        </semantic>        <semantic language="C++/LLVM">            value = getLlvmInterpreterProxy()-&gt;byteSizeOf(object);        </semantic>    </instruction>    <instruction opcode="1001" mnemonic="firstFieldPointer" kind="operation">        <name>First Fixed Field</name>        <description>Loads the first fixed field address of an object into a register.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="C/Interpreter">            pointer = interpreterProxy-&gt;firstFixedField(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcFirstFieldPointer: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := objectMemory firstFixedField: object.        </semantic>        <semantic language="C++/LLVM">            pointer = getLlvmInterpreterProxy()-&gt;firstFixedField(object);        </semantic>    </instruction>    <instruction opcode="1002" mnemonic="firstIndexableFieldPointer" kind="operation">        <name>First Indexable Field</name>        <description>Loads the first indexable field address of an object into a register.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            pointer = interpreterProxy-&gt;firstIndexableField(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcFirstIndexableFieldPointer: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := objectMemory firstIndexableField: object.        </semantic>        <semantic language="C++/LLVM">            pointer = getLlvmInterpreterProxy()-&gt;firstIndexableField(object);        </semantic>    </instruction>    <instruction opcode="1003" mnemonic="isBytes" kind="operation">        <name>Is bytes object</name>        <description>It tells if an object is bytes variable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;isBytes(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsBytes: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isBytes: object) ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;isBytes(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1004" mnemonic="isFloatObject" kind="operation">        <name>Is float object</name>        <description>It tells if an object is a float.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;isFloatObject(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsFloatObject: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isFloatObject: object) ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;isFloatObject(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1005" mnemonic="isIndexable" kind="operation">        <name>Is indexable object</name>        <description>It tells if an object is an indexable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;isIndexable(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsIndexable: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isIndexable: object) ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;isIndexable(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1006" mnemonic="isIntegerObject" kind="operation">        <name>Is integer object</name>        <description>It tells if an object is an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;isIntegerObject(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsIntegerObject: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isIntegerObject: object) ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;isIntegerObject(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1007" mnemonic="isPointers" kind="operation">        <name>Is pointers object</name>        <description>It tells if an object contains pointers.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;isPointers(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsPointers: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isPointers: object) ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;isPointers(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1008" mnemonic="isWords" kind="operation">        <name>Is Words object</name>        <description>It tells if an object is words variable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;isWords(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsWords: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isWords: object) ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;isWords(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1009" mnemonic="isWordsOrBytes" kind="operation">        <name>Is bytes object</name>        <description>It tells if an object is bytes variable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;isWordsOrBytes(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsWordsOrBytes: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isWordsOrBytes: object) ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;isWordsOrBytes(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1010" mnemonic="oopSmallIntegerToInt32" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing a small integer into an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;integerValueOf(object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genConvertSmallIntegerToIntegerInReg: object.            self ssPushNativeRegister: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := objectMemory integerValueOf: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;integerValueOf(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1011" mnemonic="oopSmallIntegerToInt64" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing a small integer boolean into a64-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;integerValueOf(object);        </semantic>        <semantic language="Smalltalk/Cog/32">            objectRepresentation genConvertSmallIntegerToIntegerInReg: object.            self MoveCq: 0 R: valueHigh.            self ssPushRegister: object secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            objectRepresentation genConvertSmallIntegerToIntegerInReg: object.            self ssPushNativeRegister: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := objectMemory integerValueOf: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;integerValueOf(object), builder.getInt64Ty(), false);        </semantic>    </instruction>    <instruction opcode="1012" mnemonic="oopToBoolean32" kind="operation">        <name>Oop to Boolean</name>        <description>Decodes an Oop representing a boolean into an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true"/>        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;booleanValueOf(object);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self booleanValueOf: object.        </semantic>        <semantic language="Smalltalk/Cog">            self annotate: (self SubCw: objectMemory falseObject R: object) objRef: objectMemory falseObject.            self ssPushNativeRegister: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;booleanValueOf(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1013" mnemonic="oopToBoolean64" kind="operation">        <name>Oop to Boolean</name>        <description>Decodes an Oop representing a boolean into an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;booleanValueOf(object);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self booleanValueOf: object.        </semantic>        <semantic language="Smalltalk/Cog/32">            self MoveCq: 0 R: valueHigh.            self annotate: (self SubCw: objectMemory falseObject R: object) objRef: objectMemory falseObject.            self ssPushRegister: object secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self annotate: (self SubCw: objectMemory falseObject R: object) objRef: objectMemory falseObject.            self ssPushNativeRegister: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;booleanValueOf(object), builder.getInt64Ty(), false);        </semantic>    </instruction>    <instruction opcode="1014" mnemonic="oopToFloat32" kind="operation">        <name>Oop to Int</name>        <description>            It decodes an Oop representing floating point number into a single            precision IEEE-754 floating point number.        </description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <float32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;floatValueOf(object);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcOop: object toFloat32: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self floatValueOf: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateFPCast(getLlvmInterpreterProxy()-&gt;floatValueOf(object), builder.getFloatTy());        </semantic>    </instruction>    <instruction opcode="1015" mnemonic="oopToFloat64" kind="operation">        <name>Oop to Int</name>        <description>            It decodes an Oop representing floating point number into a double            precision IEEE-754 floating point number.        </description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <float64 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;floatValueOf(object);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcOop: object toFloat64: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self floatValueOf: object.        </semantic>        <semantic language="C++/LLVM">            value = getLlvmInterpreterProxy()-&gt;floatValueOf(object);        </semantic>    </instruction>    <instruction opcode="1016" mnemonic="oopToInt32" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop an integer into signed 32-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;signed32BitValueOf(object);        </semantic>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcOopToInt32: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self signed32BitValueOf: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;signed32BitValueOf(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1017" mnemonic="oopToInt64" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing a signed integer into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcOop: object toInt64: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcOopToInt64: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;signed64BitValueOf(object), builder.getInt64Ty(), false);        </semantic>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;signed64BitValueOf(object);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self signed64BitValueOf: object.        </semantic>    </instruction>    <instruction opcode="1018" mnemonic="oopToPointer" kind="operation">        <name>Oop to Pointer</name>        <description>Extracts a pointer encoded in an indexable such as NBExternalAddress.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            pointer = *((void**)interpreterProxy-&gt;firstIndexableField(object));        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcOopToPointer: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self pointerAtPointer: (objectMemory firstIndexableField: object).        </semantic>        <semantic language="C++/LLVM">            llvm::Value *indexablePtr = getLlvmInterpreterProxy()-&gt;firstIndexableField(object);            llvm::Type *ptrType = llvm::PointerType::getUnqual(builder.getInt8PtrTy());            pointer = builder.CreateLoad(builder.CreatePointerCast(indexablePtr, ptrType));        </semantic>    </instruction>    <instruction opcode="1019" mnemonic="oopToPointerReinterpret" kind="operation">        <name>Cast Oop to Pointer Reinterpret</name>        <description>Reinterpret casts an Oop into a pointer.        </description>        <warning>Reinterpret casts an Oop into a pointer.        </warning>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="C/Interpreter">            pointer = (void*)object;        </semantic>        <semantic language="Smalltalk/Cog">            &quot;TODO: Generate a nop here&quot;            self ssPushNativeRegister: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self cCoerce: object to: 'char*'.        </semantic>        <semantic language="C++/LLVM">            pointer = builder.CreateIntToPtr(object, builder.getInt8PtrTy());        </semantic>    </instruction>    <instruction opcode="1020" mnemonic="oopToUInt32" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing an integer into an unsigned 32-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;positive32BitValueOf(object);        </semantic>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcOopToUInt32: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self positive32BitValueOf: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;positive32BitValueOf(object), builder.getInt32Ty(), false);        </semantic>    </instruction>    <instruction opcode="1021" mnemonic="oopToUInt64" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing an unsigned integer into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcOop: object toUInt64: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcOopToUInt64: object.        </semantic>        <semantic language="C++/LLVM">            value = builder.CreateIntCast(getLlvmInterpreterProxy()-&gt;positive64BitValueOf(object), builder.getInt64Ty(), false);        </semantic>        <semantic language="C/Interpreter">            value = interpreterProxy-&gt;positive64BitValueOf(object);        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self positive64BitValueOf: object.        </semantic>    </instruction>    <instruction opcode="1022" mnemonic="pin" kind="operation">        <name>Pin Object</name>        <description>Pins an Oop pointed object</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            /* TODO: Requires Spur */        </semantic>        <semantic language="Smalltalk/StackInterpreter">            objectMemory pinObject: object.        </semantic>    </instruction>    <instruction opcode="1023" mnemonic="unpin" kind="operation">        <name>Unpin Object</name>        <description>Unpins an Oop pointed object</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            /* TODO: Requires Spur */        </semantic>        <semantic language="Smalltalk/StackInterpreter">            objectMemory unpinObject: object.        </semantic>    </instruction>    <instruction opcode="1407" mnemonic="instantiateIndexable32Oop" kind="operation">        <name>Instantiate an oop class</name>        <description>It instantiates a class</description>        <arguments />        <stack-arguments>            <oop name="classOop" />            <int32 name="indexableSize" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            object = instantiateClassindexableSize(classOop, indexableSize);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcInstantiateOop: classOop indexableSize: indexableSize.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: classOop indexableSize: indexableSize.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;instantiateClassindexableSize(classOop, indexableSize);        </semantic>    </instruction>    <instruction opcode="1408" mnemonic="instantiateIndexableOop" kind="operation">        <name>Instantiate an indexable class</name>        <description>It instantiates a class</description>        <arguments>            <extend-a name="indexableSize" />        </arguments>        <stack-arguments>            <oop name="classOop" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="C/Interpreter">            object = instantiateClassindexableSize(classOop, indexableSize);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcInstantiateOop: classOop constantIndexableSize: indexableSize.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: classOop indexableSize: indexableSize.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;instantiateClassindexableSize(classOop, indexableSize);        </semantic>    </instruction>    <instruction opcode="1409" mnemonic="instantiateOop" kind="operation">        <name>Instantiate an oop class</name>        <description>It instantiates a class</description>        <arguments />        <stack-arguments>            <oop name="classOop" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            object = instantiateClassindexableSize(classOop, 0);        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcInstantiateOop: classOop.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: classOop indexableSize: 0.        </semantic>        <semantic language="C++/LLVM">            object = getLlvmInterpreterProxy()-&gt;instantiateClassindexableSize(classOop, 0);        </semantic>    </instruction>    <instruction opcode="1410" mnemonic="loadObjectAt" kind="operation">        <name>Load an object field.</name>        <description>This instruction loads the value of an object.</description>        <arguments />        <stack-arguments>            <oop name="object" />            <int32 name="fieldIndex" />        </stack-arguments>        <stack-results>            <oop name="fieldValue" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            fieldValue = interpreterProxy-&gt;fetchPointerofObject(fieldIndex, object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcLoadObject: object at: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            fieldValue := objectMemory fetchPointer: fieldIndex ofObject: object.        </semantic>        <semantic language="C++/LLVM">            fieldValue = getLlvmInterpreterProxy()-&gt;fetchPointerofObject(fieldIndex, object);        </semantic>    </instruction>    <instruction opcode="1411" mnemonic="loadObjectField" kind="operation">        <name>Load an object field.</name>        <description>This instruction loads the value of an object.</description>        <arguments>            <extend-a name="fieldIndex" />        </arguments>        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <oop name="fieldValue" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            fieldValue = interpreterProxy-&gt;fetchPointerofObject(fieldIndex, object);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcLoadObject: object field: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            fieldValue := self fetchPointer: fieldIndex ofObject: object.        </semantic>        <semantic language="C++/LLVM">            fieldValue = getLlvmInterpreterProxy()-&gt;fetchPointerofObject(fieldIndex, object);        </semantic>    </instruction>    <instruction opcode="2000" mnemonic="oopEqual" kind="operation">        <name>Oop Equality</name>        <description>Oop identity comparison.</description>        <arguments />        <stack-arguments>            <oop name="first" />            <oop name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="C/Interpreter">            value = first == second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpEQ(first, second));        </semantic>    </instruction>    <instruction opcode="2001" mnemonic="oopNotEqual" kind="operation">        <name>Oop Not Equality</name>        <description>Oop not identity comparison.</description>        <arguments />        <stack-arguments>            <oop name="first" />            <oop name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="C/Interpreter">            value = first != second;         </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>        <semantic language="C++/LLVM">            value = condToInt32(builder.CreateICmpNE(first, second));        </semantic>    </instruction>    <instruction opcode="2002" mnemonic="storeObjectField" kind="operation">        <name>Store an object field</name>        <description>This instruction stores an object into a field of an object.</description>        <arguments>            <extend-a name="fieldIndex" />        </arguments>        <stack-arguments>            <oop name="object" />            <oop name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            interpreterProxy-&gt;storePointerofObjectwithValue(fieldIndex, object, value);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcStore: value object: object field: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            objectMemory storePointer: fieldIndex ofObject: object withValue: value.        </semantic>        <semantic language="C++/LLVM">            getLlvmInterpreterProxy()-&gt;storePointerofObjectwithValue(fieldIndex, object, value);        </semantic>    </instruction>    <instruction opcode="2003" mnemonic="storeObjectFieldAt" kind="operation">        <name>Store an object field</name>        <description>This instruction stores an object into a field of an object.</description>        <arguments />        <stack-arguments>            <oop name="object" />            <int32 name="fieldIndex" />            <oop name="value" />        </stack-arguments>        <stack-results />        <semantic language="C/Interpreter">            interpreterProxy-&gt;storePointerofObjectwithValue(fieldIndex, object, value);        </semantic>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcStore: value object: object at: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            objectMemory storePointer: fieldIndex ofObject: object withValue: value.        </semantic>        <semantic language="C++/LLVM">            getLlvmInterpreterProxy()-&gt;storePointerofObjectwithValue(fieldIndex, object, value);        </semantic>    </instruction></lowcode>