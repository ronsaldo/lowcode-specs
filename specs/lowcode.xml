<?xml version="1.0" encoding="utf-8"?><lowcode>    <description>    The Lowcode instruction set defines a register based virtual machine for    C like low-level operations and Smalltalk object oriented pointer    manipulations.                                 <br />    Lowcode has different set of registers, one for integer, another for    object-oriented pointers and another for floating point numbers.                                <br />    Lowcode is encoded using the Sista inline primitives and they starting with    opcode inline primitive.                                <br />    </description>    <!--Lowcode  instructions-->    <instruction opcode="0" mnemonic="add32" kind="operation">        <name>Integer Addition</name>        <description>It performs integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self AddR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>    </instruction>    <instruction opcode="1" mnemonic="add64" kind="operation">        <name>Integer Addition</name>        <description>It performs integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AddR: secondLow R: firstLow.            self AddcR: secondHigh R: firstHigh.			self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AddR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>    </instruction>    <instruction opcode="2" mnemonic="alloca32" kind="operation">        <name>Alloca</name>        <description>            It allocates variable sized memory in the stack.        </description>        <arguments />        <stack-arguments>            <int32 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveAw: coInterpreter nativeStackPointerAddress R: TempReg.            self SubR: size R: TempReg.            self AndCq: -16 R: TempReg.            self MoveR: TempReg R: size.            self MoveR: size Aw: coInterpreter nativeStackPointerAddress.            self ssPushNativeRegister: size.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            nativeStackPointer := self cCoerce:                            ((self cCoerce: nativeStackPointer - size to: 'size_t') bitAnd: -16)                        to: 'char*'.            pointer := nativeStackPointer.        </semantic>    </instruction>    <instruction opcode="3" mnemonic="alloca64" kind="operation">        <name>Alloca</name>        <description>            It allocates variable sized memory in the stack.        </description>        <arguments />        <stack-arguments>            <int64 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self SubR: sizeLow R: SPReg.            self MoveR: SPReg R: sizeLow.            self ssPushNativeRegister: sizeLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SubR: size R: SPReg.            self MoveR: SPReg R: size.            self ssPushNativeRegister: size.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            nativeStackPointer := nativeStackPointer - size.            pointer := nativeStackPointer.        </semantic>    </instruction>    <instruction opcode="4" mnemonic="and32" kind="operation">        <name>Bitwise And</name>        <description>It performs a bitwise and operation.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self AndR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitAnd: second.        </semantic>    </instruction>    <instruction opcode="5" mnemonic="and64" kind="operation">        <name>Bitwise And</name>        <description>Performs a bitwise and operation.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AndR: secondLow R: firstLow.            self AndR: secondHigh R: firstHigh.            self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndR: second R: first.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitAnd: second.        </semantic>    </instruction>    <instruction opcode="6" mnemonic="arithmeticRightShift32" kind="operation">        <name>Arithmetic Right Shift</name>        <description>Performs an arithmetic right shifting.</description>        <arguments />        <stack-arguments>            <int32 name="value" />            <int32 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ArithmeticShiftRightR: shiftAmount R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>    </instruction>    <instruction opcode="7" mnemonic="arithmeticRightShift64" kind="operation">        <name>Arithmetic Right Shift</name>        <description>Performs an arithmetic right shifting.</description>        <arguments />        <stack-arguments>            <int64 name="value" />            <int64 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>    </instruction>    <instruction opcode="8" mnemonic="beginCall" kind="operation">        <name>Begins a function call.</name>        <description>Begins a function call</description>        <arguments>            <extend-a name="alignment" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self beginHighLevelCall: alignment.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            hostPlatformStoredSP := hostPlatformSP.            hostPlatformSP := self cCoerce:                            ((self cCoerce: hostPlatformSP to: 'size_t') bitAnd: alignment negated)                        to: 'char*'.        </semantic>    </instruction>    <instruction opcode="9" mnemonic="branchFalse32" kind="branch">        <name>Branch On False</name>        <description>It performs an jump if the Int32 present in the stack is equals to zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int32 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self genJumpIfBoolean32: false cond: cond to: dest.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond = 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="10" mnemonic="branchFalse64" kind="branch">        <name>Branch On False</name>        <description>It performs an jump if the Int64 present in the stack is equals to zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int64 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self OrR: condHigh R: condLow.            self genJumpIfBoolean64: true cond: condLow to: dest.        </semantic>        <semantic language="Smalltalk/Cog/64">            self genJumpIfBoolean64: true cond: cond to: dest.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond = 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="11" mnemonic="branchTrue32" kind="branch">        <name>Branch On True</name>        <description>It performs an jump if the Int32 present in the stack is different than zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int32 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self genJumpIfBoolean32: true cond: cond to: dest.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond ~= 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="12" mnemonic="branchTrue64" kind="branch">        <name>Branch On True</name>        <description>It performs an jump if the Int64 present in the stack is different than zero.</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments>            <int64 name="cond" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self OrR: condHigh R: condLow.            self genJumpIfBoolean64: true cond: condLow to: dest.        </semantic>        <semantic language="Smalltalk/Cog/64">            self genJumpIfBoolean64: true cond: cond to: dest.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            cond ~= 0 ifTrue: [                localIP := dest.            	self cppIf: MULTIPLEBYTECODESETS            		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]            		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP]            ].        </semantic>    </instruction>    <instruction opcode="13" mnemonic="callArgumentFloat32" kind="operation">        <name>Push Float32 call argument</name>        <description>Pushes a 32-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <float32 name="argumentValue" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: DPFPReg0.	        self ssNativePop: 1.            self MoveRs: DPFPReg0 M32: BytesPerWord negated r: SPReg.            self SubCq: BytesPerWord R: SPReg.            currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentFloat32: argumentValue.        </semantic>    </instruction>    <instruction opcode="14" mnemonic="callArgumentFloat64" kind="operation">        <name>Push Float64 call argument</name>        <description>Pushes a 64-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <float64 name="argumentValue" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: DPFPReg0.	        self ssNativePop: 1.            self MoveRd: DPFPReg0 M64: -8 r: SPReg.            self SubCq: 8 R: SPReg.            currentCallCleanUpSize := currentCallCleanUpSize + 8.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentFloat64: argumentValue.        </semantic>    </instruction>    <instruction opcode="15" mnemonic="callArgumentInt32" kind="operation">        <name>Pushes Int32 call argument</name>        <description>Pushes a 32-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentInt32: value.        </semantic>    </instruction>    <instruction opcode="16" mnemonic="callArgumentInt64" kind="operation">        <name>Push Int64 call argument</name>        <description>Pushes a 64-bit integer to the call stack.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/Raw">            BytesPerWord = 4 ifTrue: [	            self ssNativeTop nativeStackPopToReg: TempReg secondReg: ReceiverResultReg.	            self ssNativePop: 1.                self PushR: TempReg.                self PushR: ReceiverResultReg.                currentCallCleanUpSize := currentCallCleanUpSize + 8.            ] ifFalse: [	            self ssNativeTop nativeStackPopToReg: TempReg.	            self ssNativePop: 1.                self PushR: TempReg.                currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.            ].        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentInt64: value.        </semantic>    </instruction>    <instruction opcode="17" mnemonic="callArgumentPointer" kind="operation">        <name>Push Pointer call argument</name>        <description>Pushes a pointer to the call stack.</description>        <arguments />        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            currentCallCleanUpSize := currentCallCleanUpSize + BytesPerWord.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentPointer: pointerValue.        </semantic>    </instruction>    <instruction opcode="18" mnemonic="callArgumentStructure" kind="operation">        <name>Push structure call argument</name>        <description>Pushes a pointer to the call stack.</description>        <arguments>            <extend-a name="structureSize" />        </arguments>        <stack-arguments>            <pointer name="structurePointer" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/Raw">            "Fetch the pointer"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            "Allocate space"            self SubCq: currentCallCleanUpSize R: SPReg .            "Copy the structure"            backEnd genMemCopy: TempReg to: SPReg constantSize: extA.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentStructure: structurePointer Sized: structureSize.        </semantic>    </instruction>    <instruction opcode="19" mnemonic="callInstruction" kind="operation">        <name>Low-Level call</name>        <description>This instruction performs a Low-Level call.</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self CallRT: function.        </semantic>    </instruction>    <instruction opcode="20" mnemonic="callPhysical" kind="operation">        <name>Push Int32 from physical register</name>        <description>Pushes an Int32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self CallR: registerID.        </semantic>    </instruction>    <instruction opcode="21" mnemonic="checkSessionIdentifier" kind="operation">        <name>Pushes true or false if the session ID matches</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments>            <extend-a name="expectedSession" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: (expectedSession = coInterpreter getThisSessionID ifTrue: [1] ifFalse: [0]).        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (expectedSession = self getThisSessionID) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="22" mnemonic="compareAndSwap32" kind="operation">        <name>Compare and Swap 32 Bits</name>        <description>            Compares a 32 bit value in memory with a reference value,            if they are equal it swaps the memory location with a new value.            It returns the old value in the memory location.            This operation is guaranteed to be atomic.        </description>        <arguments />        <stack-arguments>            <pointer name="check" />            <int32 name="oldValue" />            <int32 name="newValue" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>    </instruction>    <instruction opcode="23" mnemonic="div32" kind="operation">        <name>Integer Signed Division</name>        <description>Integer signed division without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: first Rem: second.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first // second.        </semantic>    </instruction>    <instruction opcode="24" mnemonic="div64" kind="operation">        <name>Integer Signed Division</name>        <description>Integer signed division without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := first // second.        </semantic>    </instruction>    <instruction opcode="25" mnemonic="duplicateFloat32" kind="operation">        <name>Duplicate Float32</name>        <description>It duplicates the Float32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <float32 name="dup1" aliased="true" />            <float32 name="dup2" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            dup1 := value.            dup2 := value.        </semantic>        <semantic language="Smalltalk/Cog">            self MoveRs: value Rs: dup2.            self ssPushRegisterSingleFloat: value;                ssPushRegisterSingleFloat: dup2.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="26" mnemonic="duplicateFloat64" kind="operation">        <name>Duplicate Float64</name>        <description>It duplicates the Float64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="dup1" aliased="true" />            <float64 name="dup2" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveRd: value Rd: dup2.            self ssPushRegisterDoubleFloat: value;                ssPushRegisterDoubleFloat: dup2.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="27" mnemonic="duplicateInt32" kind="operation">        <name>Duplicate Int32</name>        <description>It duplicates the Int32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="dup1" aliased="true" />            <int32 name="dup2" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveR: value R: dup2.            self ssPushNativeRegister: value;                ssPushNativeRegister: dup2.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="28" mnemonic="duplicateInt64" kind="operation">        <name>Duplicate Int64</name>        <description>It duplicates the Int64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="dup1" aliased="true" />            <int64 name="dup2" />        </stack-results>        <semantic language="Smalltalk/Cog/64">            self MoveR: value R: dup2.            self ssPushNativeRegister: value.            self ssPushNativeRegister: dup2.        </semantic>        <semantic language="Smalltalk/Cog/32">            self MoveR: valueLow R: dup2Low.            self MoveR: valueHigh R: dup2High.            self ssPushRegister: valueLow secondRegister: valueHigh.            self ssPushRegister: dup2Low secondRegister: dup2High.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := value.            dup2 := value.        </semantic>    </instruction>    <instruction opcode="29" mnemonic="duplicatePointer" kind="operation">        <name>Duplicate Pointer</name>        <description>It duplicates the pointer present in the top of the stack</description>        <arguments />        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results>            <pointer name="dup1" aliased="true" />            <pointer name="dup2" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveR: pointerValue R: dup2.            self ssPushNativeRegister: pointerValue;                ssPushNativeRegister: dup2.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            dup1 := pointerValue.            dup2 := pointerValue.        </semantic>    </instruction>    <instruction opcode="30" mnemonic="effectiveAddress32" kind="operation">        <name>Compute Effective Address 32-bit</name>        <description>It computes an effective address 32-bit factors.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int32 name="index" />            <int32 name="scale" />            <int32 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MulR: scale R: index.            self AddR: index R: base.            self AddR: offset R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := base + (index*scale) + offset.        </semantic>    </instruction>    <instruction opcode="31" mnemonic="effectiveAddress64" kind="operation">        <name>Compute Effective Address 64-bit</name>        <description>It computes an effective address using 64-bit factors.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int64 name="index" />            <int64 name="scale" />            <int64 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := base + (index*scale) + offset.        </semantic>    </instruction>    <instruction opcode="32" mnemonic="endCall" kind="operation">        <name>End a function call.</name>        <description>It ends a function call by cleaning the stack.</description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self endHighLevelCallWithCleanup.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            hostPlatformSP := hostPlatformStoredSP.        </semantic>    </instruction>    <instruction opcode="33" mnemonic="endCallNoCleanup" kind="operation">        <name>End a function call.</name>        <description>It ends a function call without cleaning the stack.</description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self endHighLevelCallWithoutCleanup.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            &quot;Nop&quot;            hostPlatformSP := hostPlatformSP.        </semantic>    </instruction>    <instruction opcode="34" mnemonic="fail" kind="terminator">        <name>Returns with an error.</name>        <description>Return with error </description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self ssFlushAll.            self ensureReceiverResultRegContainsSelf.            self MoveCq: 0 R: TempReg.            self CallRT: ceSendInlinePrimitiveFailed.            self annotateBytecode: self Label.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self internalPush: self receiver.            self internalPush: (objectMemory integerObjectOf: 0).            messageSelector := self splObj: SelectorInlinePrimitiveFailed.			argumentCount := 1.            self normalSend.        </semantic>    </instruction>    <instruction opcode="35" mnemonic="failWithCode" kind="terminator">        <name>Returns with an error.</name>        <description>Return with error </description>        <arguments>            <extend-a name="errorCode" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self ensureReceiverResultRegContainsSelf.            self MoveCq: errorCode R: TempReg.            self CallRT: ceSendInlinePrimitiveFailed.            self annotateBytecode: self Label.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self internalPush: self receiver.            self internalPush: (objectMemory integerObjectOf: errorCode).            messageSelector := self splObj: SelectorInlinePrimitiveFailed.			argumentCount := 1.            self normalSend.        </semantic>    </instruction>    <instruction opcode="36" mnemonic="float32Add" kind="operation">        <name>Float32 addition</name>        <description>It Performs the addition of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self AddRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>    </instruction>    <instruction opcode="37" mnemonic="float32Div" kind="operation">        <name>Float32 division</name>        <description>It performs the division of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self DivRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first / second.        </semantic>    </instruction>    <instruction opcode="38" mnemonic="float32Equal" kind="operation">        <name>Float32 Equality</name>        <description>Float32 equality.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPNotEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="39" mnemonic="float32Great" kind="operation">        <name>Float32 Great Than</name>        <description>Float32 great than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPLessOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="40" mnemonic="float32GreatEqual" kind="operation">        <name>Float32 Great or Equal Than</name>        <description>Float32 great or equal than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPLess: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="41" mnemonic="float32Less" kind="operation">        <name>Float32 Less Than</name>        <description>Float32 less than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPGreaterOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="42" mnemonic="float32LessEqual" kind="operation">        <name>Float32 Less or Eual Than</name>        <description>Float32 less or equal than relationship.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPGreater: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="43" mnemonic="float32Mul" kind="operation">        <name>Float32 multiplication</name>        <description>It performs the multiplication of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MulRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>    </instruction>    <instruction opcode="44" mnemonic="float32NotEqual" kind="operation">        <name>Float32 Inequality</name>        <description>Float32 not equal.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRs: second Rs: first.            falseJump := self JumpFPEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="45" mnemonic="float32Sub" kind="operation">        <name>Float32 subtraction</name>        <description>It performs the subtraction of two single precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float32 name="first" />            <float32 name="second" />        </stack-arguments>        <stack-results>            <float32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self SubRs: second Rs: first.			self ssPushRegisterSingleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>    </instruction>    <instruction opcode="46" mnemonic="float32ToFloat64" kind="operation">        <name>Float32 to Float64</name>        <description>It converts a single precision floating point number into                    a double precision floating point number        </description>        <arguments />        <stack-arguments>            <float32 name="singleFloatValue" />        </stack-arguments>        <stack-results>            <float64 name="doubleResult" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertRs: singleFloatValue Rd: singleFloatValue.            self ssPushRegisterDoubleFloat: singleFloatValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            doubleResult := self cCoerce: singleFloatValue to: 'double'.        </semantic>    </instruction>    <instruction opcode="47" mnemonic="float32ToInt32" kind="operation">        <name>Float32 to Int32</name>        <description>It converts single precision floating point number into 32-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertRs: value R: result.            self ssPushNativeRegister: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'sqInt'.        </semantic>    </instruction>    <instruction opcode="48" mnemonic="float32ToInt64" kind="operation">        <name>Float32 to Int64</name>        <description>It converts a single precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'sqLong'.        </semantic>    </instruction>    <instruction opcode="49" mnemonic="float32ToUInt32" kind="operation">        <name>Float32 to UInt32</name>        <description>It converts single precision floating point number into 32-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertRs: value R: result.            self ssPushNativeRegister: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint32_t'.        </semantic>    </instruction>    <instruction opcode="50" mnemonic="float32ToUInt64" kind="operation">        <name>Float32 to UInt64</name>        <description>It converts a single precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint64_t'.        </semantic>    </instruction>    <instruction opcode="51" mnemonic="float64Add" kind="operation">        <name>Float64 addition</name>        <description>It performs the addition of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self AddRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first + second.        </semantic>    </instruction>    <instruction opcode="52" mnemonic="float64Div" kind="operation">        <name>Float64 division</name>        <description>It performs the division of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self DivRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first / second.        </semantic>    </instruction>    <instruction opcode="53" mnemonic="float64Equal" kind="operation">        <name>Float64 Equality</name>        <description>Float64 equality.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPNotEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="54" mnemonic="float64Great" kind="operation">        <name>Float64 Great Than</name>        <description>Float64 great than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPLessOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="55" mnemonic="float64GreatEqual" kind="operation">        <name>Float64 Great or Equal Than</name>        <description>Float64 great or equal than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPLess: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="56" mnemonic="float64Less" kind="operation">        <name>Float64 Less Than</name>        <description>Float64 less than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPGreaterOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="57" mnemonic="float64LessEqual" kind="operation">        <name>Float64 Less or Equal Than</name>        <description>Float32 less or equal than relationship.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPGreater: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="58" mnemonic="float64Mul" kind="operation">        <name>Float64 multiplication</name>        <description>It performs the multiplication of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MulRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>    </instruction>    <instruction opcode="59" mnemonic="float64NotEqual" kind="operation">        <name>Float64 Inequality</name>        <description>Float64 not equal.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpRd: second Rd: first.            falseJump := self JumpFPEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: value.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: value.            contJump jmpTarget: self Label.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="60" mnemonic="float64Sub" kind="operation">        <name>Float64 subtraction</name>        <description>It performs the subtraction of two double precision floating point numbers.</description>        <arguments />        <stack-arguments>            <float64 name="first" />            <float64 name="second" />        </stack-arguments>        <stack-results>            <float64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self SubRd: second Rd: first.			self ssPushRegisterDoubleFloat: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>    </instruction>    <instruction opcode="61" mnemonic="float64ToFloat32" kind="operation">        <name>Float64 to Float32</name>        <description>It converts a double precision floating point number into                    a single precision floating point number        </description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <float32 name="singleFloatResult" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertRd: floatValue Rs: floatValue.            self ssPushRegisterSingleFloat: floatValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            singleFloatResult := self cCoerce: floatValue to: 'float'.        </semantic>    </instruction>    <instruction opcode="62" mnemonic="float64ToInt32" kind="operation">        <name>Float64 to Int32</name>        <description>It converts double precision floating point number into a 32-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int32 name="int32Result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertRd: floatValue R: int32Result.            self ssPushNativeRegister: int32Result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            int32Result := self cCoerce: floatValue to: 'sqInt'.        </semantic>    </instruction>    <instruction opcode="63" mnemonic="float64ToInt64" kind="operation">        <name>Float64 to Int64</name>        <description>It converts a double precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int64 name="int64Result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            int64Result := self cCoerce: floatValue to: 'sqLong'.        </semantic>    </instruction>    <instruction opcode="64" mnemonic="float64ToUInt32" kind="operation">        <name>Float64 to UInt32</name>        <description>It converts double precision floating point number into a 32-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int32 name="int64Result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertRd: floatValue R: int64Result.            self ssPushNativeRegister: int64Result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            int64Result := self cCoerce: floatValue to: 'uint32_t'.        </semantic>    </instruction>    <instruction opcode="65" mnemonic="float64ToUInt64" kind="operation">        <name>Float64 to UInt64</name>        <description>It converts a double precision floating point number into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <float64 name="floatValue" />        </stack-arguments>        <stack-results>            <int64 name="int64Result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            int64Result := self cCoerce: floatValue to: 'uint64_t'.        </semantic>    </instruction>    <instruction opcode="66" mnemonic="free" kind="operation">        <name>Frees Memory</name>        <description>            Frees previously allocated memory in the heap.        </description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self ssFlushAll.            pointer ~= ReceiverResultReg ifTrue: [self MoveR: pointer R: ReceiverResultReg ].            self CallRT: ceFreeTrampoline.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self free: pointer.        </semantic>    </instruction>    <instruction opcode="67" mnemonic="int32Equal" kind="operation">        <name>Int32 Equality</name>        <description>Int32 equality.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="68" mnemonic="int32Great" kind="operation">        <name>Int32 Great Than</name>        <description>Int32 great than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpLessOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="69" mnemonic="int32GreatEqual" kind="operation">        <name>Int32 Great or EqualThan</name>        <description>Int32 great or equal than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpLess: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="70" mnemonic="int32Less" kind="operation">        <name>Int32 Less Than</name>        <description>Int32 not equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpGreaterOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="71" mnemonic="int32LessEqual" kind="operation">        <name>Int32 Less or Equal Than</name>        <description>Int32 less equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpGreater: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="72" mnemonic="int32NotEqual" kind="operation">        <name>Int32 Inequality</name>        <description>Float32 not equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="73" mnemonic="int32ToFloat32" kind="operation">        <name>Int32 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rs: result.            self ssPushRegisterSingleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'float'.        </semantic>    </instruction>    <instruction opcode="74" mnemonic="int32ToFloat64" kind="operation">        <name>Int32 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rd: result.            self ssPushRegisterDoubleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'double'.        </semantic>    </instruction>    <instruction opcode="75" mnemonic="int32ToPointer" kind="operation">        <name>Int32 to Pointer</name>        <description>It converts a 32-bit integer into a pointer.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            &quot;TODO: Perform a NOP here&quot;            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uintptr_t'.        </semantic>    </instruction>    <instruction opcode="76" mnemonic="int64Equal" kind="operation">        <name>Int64 Equality</name>        <description>Int64 equality.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump falseJump2 falseLabel contJump" language="Smalltalk/Cog/32">            self CmpR: secondHigh R: firstHigh.            falseJump := self JumpNonZero: 0.            self CmpR: secondLow R: firstLow.            falseJump2 := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: firstLow.            contJump := self Jump: 0.            &quot;False result&quot;            falseLabel := self MoveCq: 0 R: firstLow.            falseJump jmpTarget: falseLabel.            falseJump2 jmpTarget: falseLabel.            contJump jmpTarget: self Label.            self ssPushNativeRegister: firstLow.        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog/64">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="77" mnemonic="int64Great" kind="operation">        <name>Int64 Great Than</name>        <description>Int64 great than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="78" mnemonic="int64GreatEqual" kind="operation">        <name>Int64 Great or EqualThan</name>        <description>Int64 great or equal than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := first &gt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="79" mnemonic="int64Less" kind="operation">        <name>Int64 Less Than</name>        <description>Int64 not equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt; second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="80" mnemonic="int64LessEqual" kind="operation">        <name>Int64 Less or Equal Than</name>        <description>Int64 less equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := first &lt;= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="81" mnemonic="int64NotEqual" kind="operation">        <name>Int64 Inequality</name>        <description>Float64 not equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump falseJump2 falseLabel contJump" language="Smalltalk/Cog/32">            self CmpR: secondHigh R: firstHigh.            falseJump := self JumpNonZero: 0.            self CmpR: secondLow R: firstLow.            falseJump2 := self JumpNonZero: 0.            &quot;False result&quot;            self MoveCq: 0 R: firstLow.            contJump := self Jump: 0.            &quot;True result&quot;            falseLabel := self MoveCq: 1 R: firstLow.            falseJump jmpTarget: falseLabel.            falseJump2 jmpTarget: falseLabel.            contJump jmpTarget: self Label.            self ssPushNativeRegister: firstLow.        </semantic>        <semantic locals="falseJump contJump" language="Smalltalk/Cog/64">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="82" mnemonic="int64ToFloat32" kind="operation">        <name>Int64 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'float'.        </semantic>    </instruction>    <instruction opcode="83" mnemonic="int64ToFloat64" kind="operation">        <name>Int64 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'double'.        </semantic>    </instruction>    <instruction opcode="84" mnemonic="int64ToPointer" kind="operation">        <name>Int64 to Pointer</name>        <description>It converts a 64-bit integer into a pointer.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce:                        (self cCoerce: value to: 'intptr_t')                       to: 'char*'.        </semantic>    </instruction>    <instruction opcode="85" mnemonic="jump" kind="jump">        <name>Jump</name>        <description>Performs an Unconditional Jump</description>        <arguments>            <label name="dest" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            extB &lt; 0 ifTrue:                [extB := 0.                 ^self genJumpBackTo: dest].            self genJumpTo: dest.            &quot;The bytecode must be mapped since it can be either forward or backward, and             backwards branches must be mapped. So if forward, we need to map.&quot;            self annotateBytecode: self lastOpcode.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            localIP := dest.           	self cppIf: MULTIPLEBYTECODESETS           		ifTrue: [currentBytecode := (objectMemory byteAtPointer: localIP) + bytecodeSetSelector]           		ifFalse: [currentBytecode := objectMemory byteAtPointer: localIP].        </semantic>    </instruction>    <instruction opcode="86" mnemonic="leftShift32" kind="operation">        <name>Left Shift</name>        <description>Performs a left shifting.</description>        <arguments />        <stack-arguments>            <int32 name="value" />            <int32 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self LogicalShiftLeftR: shiftAmount R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &lt;&lt; shiftAmount.        </semantic>    </instruction>    <instruction opcode="87" mnemonic="leftShift64" kind="operation">        <name>Left Shift</name>        <description>Performs a left shifting.</description>        <arguments />        <stack-arguments>            <int64 name="value" />            <int64 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := value &lt;&lt; shiftAmount.        </semantic>    </instruction>    <instruction opcode="88" mnemonic="loadFloat32FromMemory" kind="operation">        <name>Load Float 32 from Memory</name>        <description>Loads a float 32 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <float32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM32: 0 r: pointer Rs: value.			self ssPushRegisterSingleFloat: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self singleFloatAtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="89" mnemonic="loadFloat64FromMemory" kind="operation">        <name>Load Float 64 from Memory</name>        <description>Loads a float 64 from.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <float64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM64: 0 r: pointer Rd: value.			self ssPushRegisterDoubleFloat: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self floatAtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="90" mnemonic="loadInt16FromMemory" kind="operation">        <name>Load U16 from Memory</name>        <description>Loads an U16 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM16: 0 r: pointer R: value.            self SignExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int16AtPointer: pointer.        </semantic>     </instruction>    <instruction opcode="91" mnemonic="loadInt32FromMemory" kind="operation">        <name>Load I32 from Memory</name>        <description>Loads an I32 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM32: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int32AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="92" mnemonic="loadInt64FromMemory" kind="operation">        <name>Load I64 from Memory</name>        <description>Loads an I64 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self MoveM32: 0 r: pointer R: valueLow.            self MoveM32: 4 r: pointer R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveM64: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int64AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="93" mnemonic="loadInt8FromMemory" kind="operation">        <name>Load I8 from Memory</name>        <description>Loads an I8 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM8: 0 r: pointer R: value.            self SignExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self int8AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="94" mnemonic="loadLocalAddress" kind="operation">        <name>Load local address</name>        <description>It loads a local variable address in the stack</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="pointer" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self framePointerOfNativeLocal: baseOffset in: localFP.        </semantic>    </instruction>    <instruction opcode="95" mnemonic="loadLocalFloat32" kind="operation">        <name>Load single precision float from stack</name>        <description>It loads a single precision float from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <float32 name="floatValue" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg Rs: floatValue.			self ssPushRegisterSingleFloat: floatValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            floatValue := stackPages singleFloatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="96" mnemonic="loadLocalFloat64" kind="operation">        <name>Load double precision float from stack</name>        <description>It loads a double precision float from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <float64 name="doubleValue" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM64: 0 r: TempReg Rd: doubleValue.			self ssPushRegisterDoubleFloat: doubleValue.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            doubleValue := stackPages floatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="97" mnemonic="loadLocalInt16" kind="operation">        <name>Load I16 from stack</name>        <description>It Loads an U16 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM16: 0 r: TempReg R: value.            self SignExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int16AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="98" mnemonic="loadLocalInt32" kind="operation">        <name>Load I32 from stack</name>        <description>It Loads an U32 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int32AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="99" mnemonic="loadLocalInt64" kind="operation">        <name>Load I64 from stack</name>        <description>It Loads an I64 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: valueLow.            self MoveM32: 4 r: TempReg R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM64: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int64AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="100" mnemonic="loadLocalInt8" kind="operation">        <name>Load I8 from stack</name>        <description>It Loads an U8 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM8: 0 r: TempReg R: value.            self SignExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages int8AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="101" mnemonic="loadLocalPointer" kind="operation">        <name>Load pointer from stack</name>        <description>It loads a pointer from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="pointerResult" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveMw: 0 r: TempReg R: pointerResult.			self ssPushNativeRegister: pointerResult.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointerResult := stackPages pointerAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="102" mnemonic="loadLocalUInt16" kind="operation">        <name>Load U16 from stack</name>        <description>It Loads an U16 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM16: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint16AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="103" mnemonic="loadLocalUInt32" kind="operation">        <name>Load U32 from stack</name>        <description>It Loads an U32 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint32AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="104" mnemonic="loadLocalUInt64" kind="operation">        <name>Load U8 from stack</name>        <description>It Loads an U8 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM32: 0 r: TempReg R: valueLow.            self MoveM32: 4 r: TempReg R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM64: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint64AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="105" mnemonic="loadLocalUInt8" kind="operation">        <name>Load U8 from stack</name>        <description>It Loads an U8 from the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveM8: 0 r: TempReg R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := stackPages uint8AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP).        </semantic>    </instruction>    <instruction opcode="106" mnemonic="loadPointerFromMemory" kind="operation">        <name>Load Pointer from Memory</name>        <description>Loads a pointer from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <pointer name="pointerResult" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveMw: 0 r: pointer R: pointerResult.			self ssPushNativeRegister: pointerResult.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointerResult := self pointerAtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="107" mnemonic="loadUInt16FromMemory" kind="operation">        <name>Load U16 from Memory</name>        <description>It loads an U16 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM16: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint16AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="108" mnemonic="loadUInt32FromMemory" kind="operation">        <name>Load U32 from Memory</name>        <description>Loads an U32 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM32: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint32AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="109" mnemonic="loadUInt64FromMemory" kind="operation">        <name>Load U64 from Memory</name>        <description>Loads an U64 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;TODO: Check the endianness&quot;            self MoveM32: 0 r: pointer R: valueLow.            self MoveM32: 4 r: pointer R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveM64: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint64AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="110" mnemonic="loadUInt8FromMemory" kind="operation">        <name>Load U8 from Memory</name>        <description>Loads an U8 from memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MoveM8: 0 r: pointer R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self uint8AtPointer: pointer.        </semantic>    </instruction>    <instruction opcode="111" mnemonic="localFrameSize" kind="metadata">        <name>Local Frame Size</name>        <description>This instruction is used to describe the size of the local frame.</description>        <arguments>            <extend-a name="size" />        </arguments>        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self assert: needsFrame.            hasNativeFrame := true.            "Fetch the stack"            self MoveAw: coInterpreter nativeStackPointerAddress R: TempReg.            self AddCq: 1 R: TempReg.            self MoveR: TempReg Mw: self frameOffsetOfPreviousNativeStackPointer r: FPReg.            "Store the frame pointer"            self SubCq: size R: TempReg.            self MoveR: TempReg Mw: self frameOffsetOfNativeFramePointer r: FPReg.            "Store the new stack pointer"            self MoveR: TempReg Mw: self frameOffsetOfNativeStackPointer r: FPReg.            "Allocate space for the locals"            self SubCq: 1 + coInterpreter defaultNativeStackFrameSize R: TempReg.            self MoveR: TempReg Aw: coInterpreter nativeStackPointerAddress.                    </semantic>        <semantic locals="taggedPointer" language="Smalltalk/StackInterpreter">            "Store the previous stack pointer"            self nativePreviousStackPointerIn: localFP put: nativeStackPointer + 1.            "Make the frame pointer"            nativeStackPointer := nativeStackPointer - size.            self nativeFramePointerIn: localFP put: nativeStackPointer + 1.            "Set the stack pointer"            nativeSP := nativeStackPointer + 1.            self nativeStackPointerIn: localFP put: nativeStackPointer + 1.            "Reserve space for the native stack"            nativeStackPointer := nativeStackPointer - self defaultNativeStackFrameSize.        </semantic>    </instruction>    <instruction opcode="112" mnemonic="lockRegisters" kind="operation">        <name>Lock Registers</name>        <description>            Locks the CPU register. This tells the register allocator that the            following instructions are going to modify some explicit CPU registers.        </description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            self ssFlushAll.        </semantic>    </instruction>    <instruction opcode="113" mnemonic="lockVM" kind="operation">        <name>Lock VM</name>        <description>Locks the VM to the current thread.</description>        <arguments />        <stack-arguments />         <stack-results />    </instruction>    <instruction opcode="114" mnemonic="malloc32" kind="operation">        <name>Malloc</name>        <description>            Allocates memory from heap        </description>        <arguments />        <stack-arguments>            <int32 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            size ~= ReceiverResultReg ifTrue: [self MoveR: size R: ReceiverResultReg ].            self CallRT: ceMallocTrampoline.            self MoveR: TempReg R: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self malloc: size.        </semantic>    </instruction>    <instruction opcode="115" mnemonic="malloc64" kind="operation">        <name>Malloc</name>        <description>            Allocates memory from heap        </description>        <arguments />        <stack-arguments>            <int64 name="size" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            sizeLow ~= ReceiverResultReg ifTrue: [self MoveR: sizeLow R: ReceiverResultReg ].            self CallRT: ceMallocTrampoline.            self MoveR: TempReg R: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            size ~= ReceiverResultReg ifTrue: [self MoveR: size R: ReceiverResultReg ].            self CallRT: ceMallocTrampoline.            self MoveR: TempReg R: pointer.            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self malloc: size.        </semantic>    </instruction>    <instruction opcode="116" mnemonic="memcpy32" kind="operation">        <name>Copies a block of memory</name>        <description>Copies a block of memory</description>        <arguments />        <stack-arguments>            <pointer name="dest" />            <pointer name="source" />            <int32 name="size" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/StackInterpreter">            self mem: dest cp: source y: size.        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            backEnd genMemCopy: source to: dest size: size.        </semantic>    </instruction>    <instruction opcode="117" mnemonic="memcpy64" kind="operation">        <name>Copies a block of memory</name>        <description>Copies a block of memory</description>        <arguments />        <stack-arguments>            <pointer name="dest" />            <pointer name="source" />            <int64 name="size" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/StackInterpreter">            self mem: dest cp: source y: size.        </semantic>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            backEnd genMemCopy: source to: dest size: sizeLow.        </semantic>    </instruction>    <instruction opcode="118" mnemonic="memcpyFixed" kind="operation">        <name>Copies a block of memory</name>        <description>Copies a block of memory</description>        <arguments>            <extend-a name="size" />        </arguments>        <stack-arguments>            <pointer name="dest" />            <pointer name="source" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/StackInterpreter">            self mem: dest cp: source y: size.        </semantic>        <semantic language="Smalltalk/Cog">            size = BytesPerWord ifTrue: [                self MoveMw: 0 r: source R: TempReg.                self MoveR: TempReg Mw: 0 r: dest.            ] ifFalse: [                self ssFlushAll.                backEnd genMemCopy: source to: dest constantSize: size.            ].        </semantic>    </instruction>    <instruction opcode="119" mnemonic="moveFloat32ToPhysical" kind="operation">        <name>Move Float32 To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results />    </instruction>    <instruction opcode="120" mnemonic="moveFloat64ToPhysical" kind="operation">        <name>Move Float64 Register To Physical Register</name>        <description>Moves the content of a logical register into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results />    </instruction>    <instruction opcode="121" mnemonic="moveInt32ToPhysical" kind="operation">        <name>Move Int32  To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />    </instruction>    <instruction opcode="122" mnemonic="moveInt64ToPhysical" kind="operation">        <name>Move Int64 To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />    </instruction>    <instruction opcode="123" mnemonic="movePointerToPhysical" kind="operation">        <name>Move Pointer To Physical Register</name>        <description>Moves a value into a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />    </instruction>    <instruction opcode="124" mnemonic="mul32" kind="operation">        <name>Integer Signed Multiplication</name>        <description>Integer multiplication without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MulR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>    </instruction>    <instruction opcode="125" mnemonic="mul64" kind="operation">        <name>Integer Signed Multiplication</name>        <description>Integer multiplication without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := first * second.        </semantic>    </instruction>    <instruction opcode="126" mnemonic="neg32" kind="operation">        <name>Integer Negation</name>        <description>Integer negation.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self NegateR: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value negated.        </semantic>    </instruction>    <instruction opcode="127" mnemonic="neg64" kind="operation">        <name>Integer Negation</name>        <description>Integer negation.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            &quot;Two complement negation&quot;            self NotR: valueLow.            self NotR: valueHigh.            self AddCq: 1 R: valueLow.            self AddcCq: 0 R: valueHigh.			self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self NegateR: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value negated.        </semantic>    </instruction>    <instruction opcode="128" mnemonic="not32" kind="operation">        <name>Bitwise Not</name>        <description>Performs a bitwise not.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self NotR: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitXor: -1.        </semantic>    </instruction>    <instruction opcode="129" mnemonic="not64" kind="operation">        <name>Bitwise Not</name>        <description>Performs a bitwise not.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self NotR: valueLow.            self NotR: valueHigh.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self NotR: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitXor: -1.        </semantic>    </instruction>    <instruction opcode="130" mnemonic="or32" kind="operation">        <name>Bitwise Or</name>        <description>Performs a bitwise or operation.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self OrR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitOr: second.        </semantic>    </instruction>    <instruction opcode="131" mnemonic="or64" kind="operation">        <name>Bitwise Or</name>        <description>Performs a bitwise or operation.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self OrR: secondLow R: firstLow.            self OrR: secondHigh R: firstHigh.            self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self OrR: second R: first.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitOr: second.        </semantic>    </instruction>    <instruction opcode="132" mnemonic="performCallFloat32" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with Float32 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <float32 name="result"/>        </stack-results>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRs: DPFPReg0.            self ssPushRegisterSingleFloat: DPFPReg0.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Float32Result: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="133" mnemonic="performCallFloat64" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with Float64 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <float64 name="result" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRd: DPFPReg0.            self ssPushRegisterDoubleFloat: DPFPReg0.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Float32Result: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="134" mnemonic="performCallIndirectFloat32" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with Float32 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRs: DPFPReg0.            self ssPushRegisterSingleFloat: DPFPReg0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCall: function Float32Result: result.        </semantic>    </instruction>    <instruction opcode="135" mnemonic="performCallIndirectFloat64" kind="operation">        <name>Perform indirect function call.</name>        <description>It erforms an indirect function with Float64 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            backEnd cFloatResultToRd: DPFPReg0.            self ssPushRegisterDoubleFloat: DPFPReg0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCall: function Float64Result: result.        </semantic>    </instruction>    <instruction opcode="136" mnemonic="performCallIndirectInt32" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with I32 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCall: function Int32Result: result.        </semantic>    </instruction>    <instruction opcode="137" mnemonic="performCallIndirectInt64" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with I64 result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            BytesPerWord = 4 ifTrue: [                self MoveR: backEnd cResultRegisterLow R: ReceiverResultReg.                self MoveR: backEnd cResultRegisterHigh R: Arg0Reg.                self ssPushRegister: ReceiverResultReg secondRegister: Arg0Reg.            ] ifFalse: [                self MoveR: backEnd cResultRegister R: ReceiverResultReg.                self ssPushNativeRegister: ReceiverResultReg.            ].        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Int64Result: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="138" mnemonic="performCallIndirectPointer" kind="operation">        <name>Perform indirect function call.</name>        <description>It performs an indirect function with pointer result.</description>        <arguments />        <stack-arguments>            <pointer name="function" />        </stack-arguments>        <stack-results>            <pointer name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function PointerResult: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="139" mnemonic="performCallIndirectStructure" kind="operation">        <name>Perform indirection function call.</name>        <description>It performs an indirect function with structure result.</description>        <arguments>            <extend-a name="structureSize" />        </arguments>        <stack-arguments>            <pointer name="function" />            <pointer name="result" />        </stack-arguments>        <stack-results>            <pointer name="resultPointer" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentPointer: result.            self externalizeIPandSP.            self LowcodeInterpreterCall: function StructureResult: resultPointer Size: structureSize.            self internalizeIPandSP.        </semantic>        <semantic language="Smalltalk/Cog/Raw">            "Push the result space"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            "Fetch the function pointer"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            "Call the function"            self callSwitchToCStack.            self CallRT: ceFFICalloutTrampoline.            "Fetch the result"            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.        </semantic>    </instruction>    <instruction opcode="140" mnemonic="performCallInt32" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with I32 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="result" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Int32Result: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="141" mnemonic="performCallInt64" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with I64 result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="result" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            BytesPerWord = 4 ifTrue: [                self MoveR: backEnd cResultRegisterLow R: ReceiverResultReg.                self MoveR: backEnd cResultRegisterHigh R: Arg0Reg.                self ssPushRegister: ReceiverResultReg secondRegister: Arg0Reg.            ] ifFalse: [                self MoveR: backEnd cResultRegister R: ReceiverResultReg.                self ssPushNativeRegister: ReceiverResultReg.            ].            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function Int64Result: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="142" mnemonic="performCallPointer" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with pointer result</description>        <arguments>            <extend-a name="function" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="result" allocate="true" />        </stack-results>        <semantic language="Smalltalk/Cog/Raw">            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self externalizeIPandSP.            self LowcodeInterpreterCall: function PointerResult: result.            self internalizeIPandSP.        </semantic>    </instruction>    <instruction opcode="143" mnemonic="performCallStructure" kind="operation">        <name>Perform function call.</name>        <description>Performs a function with structure result</description>        <arguments>            <extend-a name="function" />            <extend-b name="structureSize" />        </arguments>        <stack-arguments>            <pointer name="result" />        </stack-arguments>        <stack-results>            <pointer name="resultPointer" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            self LowcodeInterpreterCallArgumentPointer: result.            self externalizeIPandSP.            self LowcodeInterpreterCall: function StructureResult: resultPointer Size: structureSize.            self internalizeIPandSP.        </semantic>        <semantic language="Smalltalk/Cog/Raw">            "Push the result space"	        self ssNativeTop nativeStackPopToReg: TempReg.	        self ssNativePop: 1.            self PushR: TempReg.            "Call the function"            self callSwitchToCStack.            self MoveCw: extA R: TempReg.            self CallRT: ceFFICalloutTrampoline.            "Fetch the result"            self MoveR: backEnd cResultRegister R: ReceiverResultReg.            self ssPushNativeRegister: ReceiverResultReg.            extA := 0.            extB := 0.        </semantic>    </instruction>    <instruction opcode="144" mnemonic="plaftormCode" kind="operation">        <name>Platform Code</name>        <description>            Returns the platform code        </description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="code" />        </stack-results>    </instruction>    <instruction opcode="145" mnemonic="pointerAddOffset32" kind="operation">        <name>Adds an offset to a pointer</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int32 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Pharo/VirtualCPU">            result := base + offset.        </semantic>        <semantic language="Smalltalk/Cog">            self AddR: offset R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := base + offset.        </semantic>    </instruction>    <instruction opcode="146" mnemonic="pointerAddOffset64" kind="operation">        <name>Adds an offset to a pointer</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments />        <stack-arguments>            <pointer name="base" />            <int64 name="offset" />        </stack-arguments>        <stack-results>            <pointer name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/64">            self AddR: offset R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="Smalltalk/Cog/32">            self AddR: offsetLow R: base.            self ssPushNativeRegister: base.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := base + offset.        </semantic>    </instruction>    <instruction opcode="147" mnemonic="pointerEqual" kind="operation">        <name>Pointer Equality</name>        <description>Pointer equality comparison.</description>        <arguments />        <stack-arguments>            <pointer name="first" />            <pointer name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="148" mnemonic="pointerNotEqual" kind="operation">        <name>Pointer Not Equality</name>        <description>Pointer not equality comparison.</description>        <arguments />        <stack-arguments>            <pointer name="first" />            <pointer name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="149" mnemonic="pointerToInt32" kind="operation">        <name>Pointer to Int32</name>        <description>It converts a pointer into a 32-bit integer.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            &quot;TODO: Perform a NOP here&quot;            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: pointer to: 'uintptr_t'.        </semantic>    </instruction>    <instruction opcode="150" mnemonic="pointerToInt64" kind="operation">        <name>Pointer to Int64</name>        <description>It converts a pointer into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self MoveR: pointer R: resultLow.            self MoveCq: 0 R: resultHigh.            self ssPushRegister: resultLow secondRegister: resultHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssPushNativeRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: pointer to: 'uintptr_t'.        </semantic>    </instruction>    <instruction opcode="151" mnemonic="popFloat32" kind="operation">        <name>Pop Float32</name>        <description>It removes the Float32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="152" mnemonic="popFloat64" kind="operation">        <name>Pop Float64</name>        <description>It removes the Float64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="153" mnemonic="popInt32" kind="operation">        <name>Pop Int32</name>        <description>It removes the Int32 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="154" mnemonic="popInt64" kind="operation">        <name>Pop Int64</name>        <description>It removes the Int64 present in the top of the stack</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="155" mnemonic="popPointer" kind="operation">        <name>Pop Pointer</name>        <description>It removes the Pointer present in the top of the stack</description>        <arguments />        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="Pharo/VirtualCPU"></semantic>        <semantic language="Smalltalk/Cog"></semantic>        <semantic language="C/Interpreter"></semantic>        <semantic language="C++/LLVM"></semantic>        <semantic language="Smalltalk/StackInterpreter"></semantic>    </instruction>    <instruction opcode="156" mnemonic="pushConstantUInt32" kind="operation">        <name>Push a 32-bit integer constant</name>        <description>Pushes a 32-bit integer constant.</description>        <arguments>            <extend-a name="constant" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: constant.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := constant.        </semantic>    </instruction>    <instruction opcode="157" mnemonic="pushConstantUInt64" kind="operation">        <name>Push a 64-bit integer constant</name>        <description>Pushes a 64-bit integer constant.</description>        <arguments>            <extend-a name="constant" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt64: constant.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := constant.        </semantic>    </instruction>    <instruction opcode="158" mnemonic="pushNullPointer" kind="operation">        <name>Push Null Pointer</name>        <description>It pushes a null pointer</description>        <arguments />        <stack-arguments />        <stack-results>            <pointer name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantNativePointer: 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.        </semantic>    </instruction>    <instruction opcode="159" mnemonic="pushOne32" kind="operation">        <name>Push one constant 32-bit integer</name>        <description>Pushes a 32 bit one constant</description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: 1.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.        </semantic>    </instruction>    <instruction opcode="160" mnemonic="pushOne64" kind="operation">        <name>Push one constant 64-bit integer</name>        <description>Pushes a 64 bit one constant</description>        <arguments />        <stack-arguments />        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt64: 1.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.        </semantic>    </instruction>    <instruction opcode="161" mnemonic="pushOneFloat32" kind="operation">        <name>Push a single precision one constant</name>        <description>It pushes a single precision float of one</description>        <arguments />        <stack-arguments />        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat32: 1.0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.0.        </semantic>    </instruction>    <instruction opcode="162" mnemonic="pushOneFloat64" kind="operation">        <name>Push a single precision one constant</name>        <description>It pushes a single precision float of one</description>        <arguments />        <stack-arguments />        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat64: 1.0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 1.0.        </semantic>    </instruction>    <instruction opcode="163" mnemonic="pushPhysicalFloat32" kind="operation">        <name>Push Float32 from physical register</name>        <description>Pushes an Float32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <float32 name="value" />        </stack-results>    </instruction>    <instruction opcode="164" mnemonic="pushPhysicalFloat64" kind="operation">        <name>Push Float64 from physical register</name>        <description>Pushes an Float64 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <float64 name="value" />        </stack-results>    </instruction>    <instruction opcode="165" mnemonic="pushPhysicalInt32" kind="operation">        <name>Push Int32 from physical register</name>        <description>Pushes an Int32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <int32 name="value" />        </stack-results>    </instruction>    <instruction opcode="166" mnemonic="pushPhysicalInt64" kind="operation">        <name>Push Int64 from physical register</name>        <description>Pushes an Int32 from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <int64 name="value" />        </stack-results>    </instruction>    <instruction opcode="167" mnemonic="pushPhysicalPointer" kind="operation">        <name>Push Pointer from physical register</name>        <description>Pushes a pointer from a physical CPU register.</description>        <arguments>            <extend-a name="registerID" />        </arguments>        <stack-arguments />        <stack-results>            <pointer name="pointerValue" />        </stack-results>    </instruction>    <instruction opcode="168" mnemonic="pushSessionIdentifier" kind="operation">        <name>Pushes the unique session identifier</name>        <description>Computes a new pointer by offseting an old one.</description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: coInterpreter getThisSessionID.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self getThisSessionID.        </semantic>    </instruction>    <instruction opcode="169" mnemonic="pushZero32" kind="operation">        <name>Pushes zero constant</name>        <description>Pushes a 32 bit zero</description>        <arguments />        <stack-arguments />        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt32: 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.        </semantic>    </instruction>    <instruction opcode="170" mnemonic="pushZero64" kind="operation">        <name>Pushes zero constant</name>        <description>Pushes a 64 bit zero</description>        <arguments />        <stack-arguments />        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantInt64: 0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.        </semantic>    </instruction>    <instruction opcode="171" mnemonic="pushZeroFloat32" kind="operation">        <name>Pushes a zero single precision float constant</name>        <description>It pushes a single precision float zero</description>        <arguments />        <stack-arguments />        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat32: 0.0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.0.        </semantic>    </instruction>    <instruction opcode="172" mnemonic="pushZeroFloat64" kind="operation">        <name>Pushes a zero single precision float constant</name>        <description>It pushes a single precision float zero</description>        <arguments />        <stack-arguments />        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssPushConstantFloat64: 0.0.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := 0.0.        </semantic>    </instruction>    <instruction opcode="173" mnemonic="rem32" kind="operation">        <name>Integer Signed Remainder</name>        <description>Integer signed remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: second Rem: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first \\ second.        </semantic>    </instruction>    <instruction opcode="174" mnemonic="rem64" kind="operation">        <name>Integer Signed Remainder</name>        <description>Integer signed remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := first \\ second.        </semantic>    </instruction>    <instruction opcode="175" mnemonic="rightShift32" kind="operation">        <name>Right Shift</name>        <description>Performs a right shifting.</description>        <arguments />        <stack-arguments>            <int32 name="value" />            <int32 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self LogicalShiftRightR: shiftAmount R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>    </instruction>    <instruction opcode="176" mnemonic="rightShift64" kind="operation">        <name>Right Shift</name>        <description>Performs a right shifting.</description>        <arguments />        <stack-arguments>            <int64 name="value" />            <int64 name="shiftAmount" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := value &gt;&gt; shiftAmount.        </semantic>    </instruction>    <instruction opcode="177" mnemonic="signExtend32From16" kind="operation">        <name>Sign Extend 16-bit</name>        <description>Sign extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self SignExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'signed short'.        </semantic>    </instruction>    <instruction opcode="178" mnemonic="signExtend32From8" kind="operation">        <name>Sign Extend 8-bit</name>        <description>Sign extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self SignExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'signed char'.        </semantic>    </instruction>    <instruction opcode="179" mnemonic="signExtend64From16" kind="operation">        <name>Sign Extend 16-bit</name>        <description>Sign extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic locals="isNegative cont" language="Smalltalk/Cog/32">            self SignExtend16R: valueLow R: valueLow.            &quot;Check the sign to set the high word&quot;            self CmpCq: 0 R: valueLow.            &quot;Positive&quot;            isNegative := self JumpLess: 0.            self MoveCq: 0 R: valueHigh.            cont := self Jump: 0.            &quot;Negative&quot;            isNegative jmpTarget: (self MoveCq: -1 R: valueHigh).            cont jmpTarget: self Label.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SignExtend16R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'int16_t'.        </semantic>    </instruction>    <instruction opcode="180" mnemonic="signExtend64From32" kind="operation">        <name>Sign Extend 32-bit</name>        <description>Sign extends a 32 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic locals="isNegative cont" language="Smalltalk/Cog/32">            self MoveR: value R: resultLow.            &quot;Check the sign to set the high word&quot;            self CmpCq: 0 R: value.            &quot;Positive&quot;            isNegative := self JumpLess: 0.            self MoveCq: 0 R: resultHigh.            cont := self Jump: 0.            &quot;Negative&quot;            isNegative jmpTarget: (self MoveCq: -1 R: resultHigh).            cont jmpTarget: self Label.            self ssPushRegister: resultLow secondRegister: resultHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SignExtend32R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'int32_t'.        </semantic>    </instruction>    <instruction opcode="181" mnemonic="signExtend64From8" kind="operation">        <name>Sign Extend 8-bit</name>        <description>Sign extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic locals="isNegative cont" language="Smalltalk/Cog/32">            self SignExtend8R: valueLow R: valueLow.            &quot;Check the sign to set the high word&quot;            self CmpCq: 0 R: valueLow.            &quot;Positive&quot;            isNegative := self JumpLess: 0.            self MoveCq: 0 R: valueHigh.            cont := self Jump: 0.            &quot;Negative&quot;            isNegative jmpTarget: (self MoveCq: -1 R: valueHigh).            cont jmpTarget: self Label.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend16R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'signed char'.        </semantic>    </instruction>    <instruction opcode="182" mnemonic="storeFloat32ToMemory" kind="operation">        <name>Store Float32 in memory</name>        <description>Stores a Float32 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <float32 name="floatValue" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveRs: floatValue M32: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self singleFloatAtPointer: pointer put: floatValue.        </semantic>    </instruction>    <instruction opcode="183" mnemonic="storeFloat64ToMemory" kind="operation">        <name>Store Float64 in memory</name>        <description>Stores a Float64 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <float64 name="doubleValue" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveRd: doubleValue M64: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self floatAtPointer: pointer put: doubleValue.        </semantic>    </instruction>    <instruction opcode="184" mnemonic="storeInt16ToMemory" kind="operation">        <name>Store UInt16 in memory</name>        <description>Stores an U16 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self MoveR: TempReg M16: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int16AtPointer: pointer put: value.        </semantic>    </instruction>    <instruction opcode="185" mnemonic="storeInt32ToMemory" kind="operation">        <name>Store Int32 in memory</name>        <description>Stores an I32 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveR: value M32: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int32AtPointer: pointer put: value.        </semantic>    </instruction>    <instruction opcode="186" mnemonic="storeInt64ToMemory" kind="operation">        <name>Store Int64 in memory</name>        <description>It stores an I64 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self MoveR: valueLow M32: 0 r: pointer.            self MoveR: valueHigh M32: 4 r: pointer.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveR: value M64: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int64AtPointer: pointer put: value.        </semantic>    </instruction>    <instruction opcode="187" mnemonic="storeInt8ToMemory" kind="operation">        <name>Store UInt8 in memory</name>        <description>Stores an U8 value to the memory.</description>        <arguments />        <stack-arguments>            <pointer name="pointer" />            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self MoveR: TempReg M8: 0 r: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self int8AtPointer: pointer put: value.        </semantic>    </instruction>    <instruction opcode="188" mnemonic="storeLocalFloat32" kind="operation">        <name>Store single precision float in the stack frame</name>        <description>It stores a single precision float in the stack frame..</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveRs: value M32: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages singleFloatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>    </instruction>    <instruction opcode="189" mnemonic="storeLocalFloat64" kind="operation">        <name>Store double precision float in the stack frame</name>        <description>It stores a double precision float in the stack frame.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveRd: value M64: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages floatAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>    </instruction>    <instruction opcode="190" mnemonic="storeLocalInt16" kind="operation">        <name>Store I16 to stack frame</name>        <description>It stores an I16 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self loadNativeLocalAddress: baseOffset to: value.            self MoveR: TempReg M16: 0 r: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages int16AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>    </instruction>    <instruction opcode="191" mnemonic="storeLocalInt32" kind="operation">        <name>Store I32 to stack frame</name>        <description>It stores an I32 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveR: value M32: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages int32AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>    </instruction>    <instruction opcode="192" mnemonic="storeLocalInt64" kind="operation">        <name>Store I64 to stack frame</name>        <description>It stores an I64 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog/32">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveR: valueLow M32: 0 r: TempReg.            self MoveR: valueHigh M32: 4 r: TempReg.        </semantic>        <semantic language="Smalltalk/Cog/64">            self MoveR: value M64: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter/Raw">            &lt;var: #valueInt64 type: #'sqLong'&gt;            |valueInt64|            BytesPerWord = 4 ifTrue: [                self lowcodeStoreLocalInt64Workaround: extA in: localFP sp: localSP.            ] ifFalse: [                valueInt64 := self internalPopStackInt64.                stackPages int64AtPointer: (self framePointerOfNativeLocal: extA in: localFP) put: valueInt64.            ].            extA := 0.        </semantic>    </instruction>    <instruction opcode="193" mnemonic="storeLocalInt8" kind="operation">        <name>Store I8 to stack frame</name>        <description>It stores an I8 to the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveR: value R: TempReg.            self loadNativeLocalAddress: baseOffset to: value.            self MoveR: TempReg M8: 0 r: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages int8AtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: value.        </semantic>    </instruction>    <instruction opcode="194" mnemonic="storeLocalPointer" kind="operation">        <name>Store pointer in the stack frame</name>        <description>It stores a pointer in the stack frame memory.</description>        <arguments>            <extend-a name="baseOffset" />        </arguments>        <stack-arguments>            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self loadNativeLocalAddress: baseOffset to: TempReg.            self MoveR: pointerValue Mw: 0 r: TempReg.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            stackPages pointerAtPointer: (self framePointerOfNativeLocal: baseOffset in: localFP) put: pointerValue.        </semantic>    </instruction>    <instruction opcode="195" mnemonic="storePointerToMemory" kind="operation">        <name>Store a pointer in memory</name>        <description>Stores pointer int the memory.</description>        <arguments />        <stack-arguments>            <pointer name="memoryPointer" />            <pointer name="pointerValue" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            self MoveR: pointerValue Mw: 0 r: memoryPointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            self pointerAtPointer: memoryPointer put: pointerValue.        </semantic>    </instruction>    <instruction opcode="196" mnemonic="sub32" kind="operation">        <name>Integer Subtraction</name>        <description>Integer subtraction without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self SubR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>    </instruction>    <instruction opcode="197" mnemonic="sub64" kind="operation">        <name>Integer Subtraction</name>        <description>Integer subtraction without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self SubR: secondLow R: firstLow.            self SubbR: secondHigh R: firstHigh.			self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self SubR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first - second.        </semantic>    </instruction>    <instruction opcode="198" mnemonic="truncate32To16" kind="operation">        <name>Truncate 32-bit to 16-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self AndCq: 16rFFFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFFFF.        </semantic>    </instruction>    <instruction opcode="199" mnemonic="truncate32To8" kind="operation">        <name>Truncate 32-bit to 8-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self AndCq: 16rFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFF.        </semantic>    </instruction>    <instruction opcode="200" mnemonic="truncate64To16" kind="operation">        <name>Truncate 64-bit to 16-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AndCq: 16rFFFF R: valueLow.            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndCq: 16rFFFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFFFF.        </semantic>    </instruction>    <instruction opcode="201" mnemonic="truncate64To32" kind="operation">        <name>Truncate 64-bit to 32-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndCq: 16rFFFFFFFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFFFFFFFF.        </semantic>    </instruction>    <instruction opcode="202" mnemonic="truncate64To8" kind="operation">        <name>Truncate 64-bit to 8-bit integer</name>        <description>Truncates an integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self AndCq: 16rFF R: valueLow.            self ssPushNativeRegister: valueLow.        </semantic>        <semantic language="Smalltalk/Cog/64">            self AndCq: 16rFF R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := value bitAnd: 16rFF.        </semantic>    </instruction>    <instruction opcode="203" mnemonic="udiv32" kind="operation">        <name>Integer Unsigned division</name>        <description>Integer unsigned division without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: first Rem: second.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') //                        (self cCoerce: second to: 'unsigned int').        </semantic>    </instruction>    <instruction opcode="204" mnemonic="udiv64" kind="operation">        <name>Integer Unsigned division</name>        <description>Integer unsigned division without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'uint64_t') //                        (self cCoerce: second to: 'uint64_t').        </semantic>    </instruction>    <instruction opcode="205" mnemonic="uint32Great" kind="operation">        <name>UInt32 Great Than</name>        <description>UInt32 great than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpBelowOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &gt;                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="206" mnemonic="uint32GreatEqual" kind="operation">        <name>UInt32 Great or Equal Than</name>        <description>UInt32 great or equal than.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpBelow: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &gt;=                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="207" mnemonic="uint32Less" kind="operation">        <name>UInt32 Less Than</name>        <description>UInt32 not equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpAboveOrEqual: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &lt;                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="208" mnemonic="uint32LessEqual" kind="operation">        <name>UInt32 Less or Equal Than</name>        <description>UInt32 less equal.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpAbove: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'unsigned int') &lt;=                        (self cCoerce: second to: 'unsigned int') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="209" mnemonic="uint32ToFloat32" kind="operation">        <name>UInt32 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rs: result.            self ssPushRegisterSingleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'unsigned int') to: 'float'.        </semantic>    </instruction>    <instruction opcode="210" mnemonic="uint32ToFloat64" kind="operation">        <name>UInt32 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ConvertR: value Rd: result.            self ssPushRegisterDoubleFloat: result.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'unsigned int') to: 'double'.        </semantic>    </instruction>    <instruction opcode="211" mnemonic="uint64Great" kind="operation">        <name>UInt32 Great Than</name>        <description>UInt64 great than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &gt;                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="212" mnemonic="uint64GreatEqual" kind="operation">        <name>UInt64 Great or Equal Than</name>        <description>UInt64 great or equal than.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &gt;=                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="213" mnemonic="uint64Less" kind="operation">        <name>UInt64 Less Than</name>        <description>UInt64 not equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &lt;                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="214" mnemonic="uint64LessEqual" kind="operation">        <name>UInt64 Less or Equal Than</name>        <description>UInt64 less equal.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := (self cCoerce: first to: 'uint64_t') &lt;=                        (self cCoerce: second to: 'uint64_t') ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="215" mnemonic="uint64ToFloat32" kind="operation">        <name>UInt64 to Float32</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float32 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'uint64_t') to: 'float'.        </semantic>    </instruction>    <instruction opcode="216" mnemonic="uint64ToFloat64" kind="operation">        <name>UInt64 to Float64</name>        <description>Converts an unsigned integer into a floating point number.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <float64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: (self cCoerce: value to: 'uint64_t') to: 'double'.        </semantic>    </instruction>    <instruction opcode="217" mnemonic="umul32" kind="operation">        <name>Integer Unsigned Multiplication</name>        <description>Integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self MulR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') *                        (self cCoerce: second to: 'unsigned int').        </semantic>    </instruction>    <instruction opcode="218" mnemonic="umul64" kind="operation">        <name>Integer Unsigned Multiplication</name>        <description>Integer addition without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'uint64_t') *                        (self cCoerce: second to: 'uint64_t').        </semantic>    </instruction>    <instruction opcode="219" mnemonic="unlockRegisters" kind="operation">        <name>Unlock Registers</name>        <description>            Unlocks the CPU register. This tells the register allocator that the            following instructions don't require specific CPU registers.        </description>        <arguments />        <stack-arguments />        <stack-results />        <semantic language="Smalltalk/Cog">            &quot;Do nothing for now&quot;        </semantic>    </instruction>    <instruction opcode="220" mnemonic="unlockVM" kind="operation">        <name>Unlock VM</name>        <description>Unlocks the VM from the current thread.</description>        <arguments />        <stack-arguments />        <stack-results />    </instruction>    <instruction opcode="221" mnemonic="urem32" kind="operation">        <name>Integer Unsigned remainder</name>        <description>Integer unsigned remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self DivR: second R: first Quo: second Rem: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') \\                        (self cCoerce: second to: 'unsigned int').        </semantic>    </instruction>    <instruction opcode="222" mnemonic="urem64" kind="operation">        <name>Integer Unsigned remainder</name>        <description>Integer unsigned remainder without overflow check.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            result := (self cCoerce: first to: 'unsigned int') \\                        (self cCoerce: second to: 'unsigned int').        </semantic>    </instruction>    <instruction opcode="223" mnemonic="xor32" kind="operation">        <name>Bitwise Xor</name>        <description>Performs a bitwise xor operation.</description>        <arguments />        <stack-arguments>            <int32 name="first" />            <int32 name="second" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self XorR: second R: first.			self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitXor: second.        </semantic>    </instruction>    <instruction opcode="224" mnemonic="xor64" kind="operation">        <name>Bitwise Xor</name>        <description>Performs a bitwise xor operation.</description>        <arguments />        <stack-arguments>            <int64 name="first" />            <int64 name="second" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self XorR: secondLow R: firstLow.            self XorR: secondHigh R: firstHigh.            self ssPushRegister: firstLow secondRegister: firstHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self XorR: second R: first.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := first bitXor: second.        </semantic>    </instruction>    <instruction opcode="225" mnemonic="zeroExtend32From16" kind="operation">        <name>Zero Extend 16-bit</name>        <description>Zero extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ZeroExtend16R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint16_t'.        </semantic>    </instruction>    <instruction opcode="226" mnemonic="zeroExtend32From8" kind="operation">        <name>Zero Extend 8-bit</name>        <description>Zero extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int32 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ZeroExtend8R: value R: value.			self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint8_t'.        </semantic>    </instruction>    <instruction opcode="227" mnemonic="zeroExtend64From16" kind="operation">        <name>Sign Extend 16-bit</name>        <description>Sign extends a 16 bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ZeroExtend16R: valueLow R: valueLow.            self MoveCq: 0 R: valueHigh.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend16R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint16_t'.        </semantic>    </instruction>    <instruction opcode="228" mnemonic="zeroExtend64From32" kind="operation">        <name>Sign Extend 32-bit</name>        <description>Sign extends a 32 bit integer value.</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self MoveR: value R: resultLow.            self MoveCq: 0 R: resultHigh.            self ssPushRegister: resultLow secondRegister: resultHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend32R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint32_t'.        </semantic>    </instruction>    <instruction opcode="229" mnemonic="zeroExtend64From8" kind="operation">        <name>Zero Extend 8-bit</name>        <description>Zero extends a 8-bit integer value.</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <int64 name="result" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ZeroExtend8R: valueLow R: valueLow.            self MoveCq: 0 R: valueHigh.            self ssPushRegister: valueLow secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ZeroExtend8R: value R: value.            self ssPushNativeRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            result := self cCoerce: value to: 'uint8_t'.        </semantic>    </instruction>    <instruction opcode="400" mnemonic="boolean32ToOop" kind="operation">        <name>Boolean to Oop</name>        <description>It converts an integer representing a boolean into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic locals="trueJump cont inst" language="Smalltalk/Cog">            self CmpCq: 0 R: value.            trueJump := self JumpNonZero: 0.            &quot;False&quot;            self annotate: (self MoveCw: objectMemory falseObject R: value) objRef: objectMemory falseObject.            cont := self Jump: 0.            &quot;True&quot;            inst := self MoveCw: objectMemory trueObject R: value.            trueJump jmpTarget: inst.            self annotate: inst objRef: objectMemory trueObject.            cont jmpTarget: self Label.            self ssPushRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := value ~= 0 ifTrue: [ objectMemory trueObject ] ifFalse: [objectMemory falseObject].        </semantic>    </instruction>    <instruction opcode="401" mnemonic="boolean64ToOop" kind="operation">        <name>Boolean to Oop</name>        <description>It converts an integer representing a boolean into an oop</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic locals="trueJump trueJump2 cont inst" language="Smalltalk/Cog/32">            self OrR: valueLow R: valueHigh.            trueJump := self JumpNonZero: 0.            &quot;False&quot;            self annotate: (self MoveCw: objectMemory falseObject R: valueLow) objRef: objectMemory falseObject.            cont := self Jump: 0.            &quot;True&quot;            inst := self MoveCw: objectMemory trueObject R: valueLow.            trueJump jmpTarget: inst.            self annotate: inst objRef: objectMemory trueObject.            cont jmpTarget: self Label.            self ssPushRegister: valueLow.        </semantic>        <semantic locals="trueJump cont inst" language="Smalltalk/Cog/64">            self CmpCq: 0 R: value.            trueJump := self JumpNonZero: 0.            &quot;False&quot;            self annotate: (self MoveCw: objectMemory falseObject R: value) objRef: objectMemory falseObject.            cont := self Jump: 0.            &quot;True&quot;            inst := self MoveCw: objectMemory trueObject R: value.            trueJump jmpTarget: inst.            self annotate: inst objRef: objectMemory trueObject.            cont jmpTarget: self Label.            self ssPushRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := value ~= 0 ifTrue: [ objectMemory trueObject ] ifFalse: [objectMemory falseObject].        </semantic>    </instruction>    <instruction opcode="402" mnemonic="float32ToOop" kind="operation">        <name>float32 to Opp</name>        <description>It converts a single precision IEEE 754 floating point number into an oop</description>        <arguments />        <stack-arguments>            <float32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcFloat32: value toOop: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self floatObjectOf: value.        </semantic>    </instruction>    <instruction opcode="403" mnemonic="float64ToOop" kind="operation">        <name>float64 to Opp</name>        <description>It converts a double precision IEEE 754 floating point number into an oop</description>        <arguments />        <stack-arguments>            <float64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcFloat64: value toOop: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self floatObjectOf: value.        </semantic>    </instruction>    <instruction opcode="404" mnemonic="int32ToOop" kind="operation">        <name>Int32 to Opp</name>        <description>It converts a signed integer into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcInt32ToOop: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory signed32BitIntegerFor: value.        </semantic>    </instruction>    <instruction opcode="405" mnemonic="int64ToOop" kind="operation">        <name>Int32 to Opp</name>        <description>It converts a signed 64-bit integer into an oop</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcInt64ToOop: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcInt64ToOop: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory signed64BitIntegerFor: value.        </semantic>    </instruction>    <instruction opcode="406" mnemonic="pointerToOop" kind="operation">        <name>Pointer to Oop</name>        <description>Encapsulates a pointer in an object</description>        <arguments>            <literal name="pointerClassLiteral" />        </arguments>        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcPointerToOop: pointer class: pointerClassLiteral.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: pointerClassLiteral indexableSize: BytesPerWord.            self pointerAtPointer: (objectMemory firstIndexableField: object) put: pointer.        </semantic>    </instruction>    <instruction opcode="407" mnemonic="pointerToOopReinterprer" kind="operation">        <name>Casts Pointer to Oop Reinterpret</name>        <description>Reinterpret casts a pointer into an Oop.        </description>        <warning>Reinterpret casts a pointer into an Oop.        </warning>        <arguments />        <stack-arguments>            <pointer name="pointer" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            &quot;TODO: Generate a nop here&quot;            self ssPushRegister: pointer.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self cCoerce: pointer to: 'sqInt'.        </semantic>    </instruction>    <instruction opcode="408" mnemonic="smallInt32ToOop" kind="operation">        <name>SmallInteger32 to Opp</name>        <description>It converts a small integer into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genConvertIntegerToSmallIntegerInScratchReg: value.            self ssPushRegister: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory integerObjectOf: value.        </semantic>    </instruction>    <instruction opcode="409" mnemonic="uint32ToOop" kind="operation">        <name>UInt32 to Opp</name>        <description>It converts an unsigned integer into an oop</description>        <arguments />        <stack-arguments>            <int32 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcUInt32ToOop: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory positive32BitIntegerFor: value.        </semantic>    </instruction>    <instruction opcode="410" mnemonic="uint64ToOop" kind="operation">        <name>UInt64 to Opp</name>        <description>It converts an unsigned integer into an oop</description>        <arguments />        <stack-arguments>            <int64 name="value" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcUInt64ToOop: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcUInt64ToOop: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := self positive64BitIntegerFor: value.        </semantic>    </instruction>    <instruction opcode="1000" mnemonic="byteSizeOf" kind="operation">        <name>Byte size of object</name>        <description>It tells the number of variable bytes of an object</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcByteSizeOf: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self byteSizeOf: object.        </semantic>    </instruction>    <instruction opcode="1001" mnemonic="firstFieldPointer" kind="operation">        <name>First Fixed Field</name>        <description>Loads the first fixed field address of an object into a register.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcFirstFieldPointer: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := objectMemory firstFixedField: object.        </semantic>    </instruction>    <instruction opcode="1002" mnemonic="firstIndexableFieldPointer" kind="operation">        <name>First Indexable Field</name>        <description>Loads the first indexable field address of an object into a register.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcFirstIndexableFieldPointer: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := objectMemory firstIndexableField: object.        </semantic>    </instruction>    <instruction opcode="1003" mnemonic="isBytes" kind="operation">        <name>Is bytes object</name>        <description>It tells if an object is bytes variable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsBytes: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isBytes: object) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="1004" mnemonic="isFloatObject" kind="operation">        <name>Is float object</name>        <description>It tells if an object is a float.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsFloatObject: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isFloatObject: object) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="1005" mnemonic="isIndexable" kind="operation">        <name>Is indexable object</name>        <description>It tells if an object is an indexable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsIndexable: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isIndexable: object) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="1006" mnemonic="isIntegerObject" kind="operation">        <name>Is integer object</name>        <description>It tells if an object is an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsIntegerObject: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isIntegerObject: object) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="1007" mnemonic="isPointers" kind="operation">        <name>Is pointers object</name>        <description>It tells if an object contains pointers.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsPointers: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isPointers: object) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="1008" mnemonic="isWords" kind="operation">        <name>Is Words object</name>        <description>It tells if an object is words variable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsWords: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isWords: object) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="1009" mnemonic="isWordsOrBytes" kind="operation">        <name>Is bytes object</name>        <description>It tells if an object is bytes variable.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcIsWordsOrBytes: object to: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := (objectMemory isWordsOrBytes: object) ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="1010" mnemonic="oopSmallIntegerToInt32" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing a small integer into an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genConvertSmallIntegerToIntegerInReg: object.            self ssPushNativeRegister: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := objectMemory integerValueOf: object.        </semantic>    </instruction>    <instruction opcode="1011" mnemonic="oopSmallIntegerToInt64" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing a small integer boolean into a64-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            objectRepresentation genConvertSmallIntegerToIntegerInReg: object.            self MoveCq: 0 R: valueHigh.            self ssPushRegister: object secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            objectRepresentation genConvertSmallIntegerToIntegerInReg: object.            self ssPushNativeRegister: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := objectMemory integerValueOf: object.        </semantic>    </instruction>    <instruction opcode="1012" mnemonic="oopToBoolean32" kind="operation">        <name>Oop to Boolean</name>        <description>Decodes an Oop representing a boolean into an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true"/>        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := self booleanValueOf: object.        </semantic>        <semantic language="Smalltalk/Cog">            self annotate: (self SubCw: objectMemory falseObject R: object) objRef: objectMemory falseObject.            self ssPushNativeRegister: object.        </semantic>    </instruction>    <instruction opcode="1013" mnemonic="oopToBoolean64" kind="operation">        <name>Oop to Boolean</name>        <description>Decodes an Oop representing a boolean into an integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/StackInterpreter">            value := self booleanValueOf: object.        </semantic>        <semantic language="Smalltalk/Cog/32">            self MoveCq: 0 R: valueHigh.            self annotate: (self SubCw: objectMemory falseObject R: object) objRef: objectMemory falseObject.            self ssPushRegister: object secondRegister: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self annotate: (self SubCw: objectMemory falseObject R: object) objRef: objectMemory falseObject.            self ssPushNativeRegister: object.        </semantic>    </instruction>    <instruction opcode="1014" mnemonic="oopToFloat32" kind="operation">        <name>Oop to Int</name>        <description>            It decodes an Oop representing floating point number into a single            precision IEEE-754 floating point number.        </description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <float32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcOop: object toFloat32: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self floatValueOf: object.        </semantic>    </instruction>    <instruction opcode="1015" mnemonic="oopToFloat64" kind="operation">        <name>Oop to Int</name>        <description>            It decodes an Oop representing floating point number into a double            precision IEEE-754 floating point number.        </description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <float64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcOop: object toFloat64: value.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self floatValueOf: object.        </semantic>    </instruction>    <instruction opcode="1016" mnemonic="oopToInt32" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop an integer into signed 32-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcOopToInt32: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self signed32BitValueOf: object.        </semantic>    </instruction>    <instruction opcode="1017" mnemonic="oopToInt64" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing a signed integer into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcOop: object toInt64: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcOopToInt64: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self signed64BitValueOf: object.        </semantic>    </instruction>    <instruction opcode="1018" mnemonic="oopToPointer" kind="operation">        <name>Oop to Pointer</name>        <description>Extracts a pointer encoded in an indexable such as NBExternalAddress.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcOopToPointer: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self pointerAtPointer: (objectMemory firstIndexableField: object).        </semantic>    </instruction>    <instruction opcode="1019" mnemonic="oopToPointerReinterpret" kind="operation">        <name>Cast Oop to Pointer Reinterpret</name>        <description>Reinterpret casts an Oop into a pointer.        </description>        <warning>Reinterpret casts an Oop into a pointer.        </warning>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <pointer name="pointer" />        </stack-results>        <semantic language="Smalltalk/Cog">            &quot;TODO: Generate a nop here&quot;            self ssPushNativeRegister: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            pointer := self cCoerce: object to: 'char*'.        </semantic>    </instruction>    <instruction opcode="1020" mnemonic="oopToUInt32" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing an integer into an unsigned 32-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog">        	self ssFlushAll.            objectRepresentation genLcOopToUInt32: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self positive32BitValueOf: object.        </semantic>    </instruction>    <instruction opcode="1021" mnemonic="oopToUInt64" kind="operation">        <name>Oop to Int</name>        <description>It decodes an Oop representing an unsigned integer into a 64-bit integer.</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <int64 name="value" />        </stack-results>        <semantic language="Smalltalk/Cog/32">            self ssFlushAll.            objectRepresentation genLcOop: object toUInt64: valueLow highPart: valueHigh.        </semantic>        <semantic language="Smalltalk/Cog/64">            self ssFlushAll.            objectRepresentation genLcOopToUInt64: object.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := self positive64BitValueOf: object.        </semantic>    </instruction>    <instruction opcode="1022" mnemonic="pin" kind="operation">        <name>Pin Object</name>        <description>Pins an Oop pointed object</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/StackInterpreter">            objectMemory pinObject: object.        </semantic>    </instruction>    <instruction opcode="1023" mnemonic="unpin" kind="operation">        <name>Unpin Object</name>        <description>Unpins an Oop pointed object</description>        <arguments />        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/StackInterpreter">            objectMemory unpinObject: object.        </semantic>    </instruction>    <instruction opcode="1407" mnemonic="instantiateIndexable32Oop" kind="operation">        <name>Instantiate an oop class</name>        <description>It instantiates a class</description>        <arguments />        <stack-arguments>            <oop name="classOop" />            <int32 name="indexableSize" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcInstantiateOop: classOop indexableSize: indexableSize.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: classOop indexableSize: indexableSize.        </semantic>    </instruction>    <instruction opcode="1408" mnemonic="instantiateIndexableOop" kind="operation">        <name>Instantiate an indexable class</name>        <description>It instantiates a class</description>        <arguments>            <extend-a name="indexableSize" />        </arguments>        <stack-arguments>            <oop name="classOop" />        </stack-arguments>        <stack-results>            <oop name="object" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcInstantiateOop: classOop constantIndexableSize: indexableSize.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: classOop indexableSize: indexableSize.        </semantic>    </instruction>    <instruction opcode="1409" mnemonic="instantiateOop" kind="operation">        <name>Instantiate an oop class</name>        <description>It instantiates a class</description>        <arguments />        <stack-arguments>            <oop name="classOop" />        </stack-arguments>        <stack-results>            <oop name="object" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            self ssFlushAll.            objectRepresentation genLcInstantiateOop: classOop.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            object := objectMemory instantiateClass: classOop indexableSize: 0.        </semantic>    </instruction>    <instruction opcode="1410" mnemonic="loadObjectAt" kind="operation">        <name>Load an object field.</name>        <description>This instruction loads the value of an object.</description>        <arguments />        <stack-arguments>            <oop name="object" />            <int32 name="fieldIndex" />        </stack-arguments>        <stack-results>            <oop name="fieldValue" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcLoadObject: object at: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            fieldValue := objectMemory fetchPointer: fieldIndex ofObject: object.        </semantic>    </instruction>    <instruction opcode="1411" mnemonic="loadObjectField" kind="operation">        <name>Load an object field.</name>        <description>This instruction loads the value of an object.</description>        <arguments>            <extend-a name="fieldIndex" />        </arguments>        <stack-arguments>            <oop name="object" />        </stack-arguments>        <stack-results>            <oop name="fieldValue" aliased="true" />        </stack-results>        <semantic language="Smalltalk/Cog">            objectRepresentation genLcLoadObject: object field: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            fieldValue := self fetchPointer: fieldIndex ofObject: object.        </semantic>    </instruction>    <instruction opcode="2000" mnemonic="oopEqual" kind="operation">        <name>Oop Equality</name>        <description>Oop identity comparison.</description>        <arguments />        <stack-arguments>            <oop name="first" />            <oop name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpNonZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first = second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="2001" mnemonic="oopNotEqual" kind="operation">        <name>Oop Not Equality</name>        <description>Oop not identity comparison.</description>        <arguments />        <stack-arguments>            <oop name="first" />            <oop name="second" />        </stack-arguments>        <stack-results>            <int32 name="value" aliased="true" />        </stack-results>        <semantic locals="falseJump contJump" language="Smalltalk/Cog">            self CmpR: second R: first.            falseJump := self JumpZero: 0.            &quot;True result&quot;            self MoveCq: 1 R: first.            contJump := self Jump: 0.            &quot;False result&quot;            falseJump jmpTarget: self Label.            self MoveCq: 0 R: first.            contJump jmpTarget: self Label.            self ssPushNativeRegister: first.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            value := first ~= second ifTrue: [1] ifFalse: [0].        </semantic>    </instruction>    <instruction opcode="2002" mnemonic="storeObjectField" kind="operation">        <name>Store an object field</name>        <description>This instruction stores an object into a field of an object.</description>        <arguments>            <extend-a name="fieldIndex" />        </arguments>        <stack-arguments>            <oop name="object" />            <oop name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            objectRepresentation genLcStore: value object: object field: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            objectMemory storePointer: fieldIndex ofObject: object withValue: value.        </semantic>    </instruction>    <instruction opcode="2003" mnemonic="storeObjectFieldAt" kind="operation">        <name>Store an object field</name>        <description>This instruction stores an object into a field of an object.</description>        <arguments />        <stack-arguments>            <oop name="object" />            <int32 name="fieldIndex" />            <oop name="value" />        </stack-arguments>        <stack-results />        <semantic language="Smalltalk/Cog">            objectRepresentation genLcStore: value object: object at: fieldIndex.        </semantic>        <semantic language="Smalltalk/StackInterpreter">            objectMemory storePointer: fieldIndex ofObject: object withValue: value.        </semantic>    </instruction></lowcode>